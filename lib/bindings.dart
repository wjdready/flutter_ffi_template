// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// bindings
class flutter_ffi_template {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  flutter_ffi_template(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  flutter_ffi_template.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Is this an error handle?
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsError(
    Object handle,
  ) {
    return _Dart_IsError(
      handle,
    );
  }

  late final _Dart_IsErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsError');
  late final _Dart_IsError =
      _Dart_IsErrorPtr.asFunction<bool Function(Object)>();

  /// Is this an api error handle?
  ///
  /// Api error handles are produced when an api function is misused.
  /// This happens when a Dart embedding api function is called with
  /// invalid arguments or in an invalid context.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsApiError(
    Object handle,
  ) {
    return _Dart_IsApiError(
      handle,
    );
  }

  late final _Dart_IsApiErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsApiError');
  late final _Dart_IsApiError =
      _Dart_IsApiErrorPtr.asFunction<bool Function(Object)>();

  /// Is this an unhandled exception error handle?
  ///
  /// Unhandled exception error handles are produced when, during the
  /// execution of Dart code, an exception is thrown but not caught.
  /// This can occur in any function which triggers the execution of Dart
  /// code.
  ///
  /// See Dart_ErrorGetException and Dart_ErrorGetStackTrace.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsUnhandledExceptionError(
    Object handle,
  ) {
    return _Dart_IsUnhandledExceptionError(
      handle,
    );
  }

  late final _Dart_IsUnhandledExceptionErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsUnhandledExceptionError');
  late final _Dart_IsUnhandledExceptionError =
      _Dart_IsUnhandledExceptionErrorPtr.asFunction<bool Function(Object)>();

  /// Is this a compilation error handle?
  ///
  /// Compilation error handles are produced when, during the execution
  /// of Dart code, a compile-time error occurs.  This can occur in any
  /// function which triggers the execution of Dart code.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsCompilationError(
    Object handle,
  ) {
    return _Dart_IsCompilationError(
      handle,
    );
  }

  late final _Dart_IsCompilationErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsCompilationError');
  late final _Dart_IsCompilationError =
      _Dart_IsCompilationErrorPtr.asFunction<bool Function(Object)>();

  /// Is this a fatal error handle?
  ///
  /// Fatal error handles are produced when the system wants to shut down
  /// the current isolate.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsFatalError(
    Object handle,
  ) {
    return _Dart_IsFatalError(
      handle,
    );
  }

  late final _Dart_IsFatalErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsFatalError');
  late final _Dart_IsFatalError =
      _Dart_IsFatalErrorPtr.asFunction<bool Function(Object)>();

  /// Gets the error message from an error handle.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \return A C string containing an error message if the handle is
  /// error. An empty C string ("") if the handle is valid. This C
  /// String is scope allocated and is only valid until the next call
  /// to Dart_ExitScope.
  ffi.Pointer<ffi.Char> Dart_GetError(
    Object handle,
  ) {
    return _Dart_GetError(
      handle,
    );
  }

  late final _Dart_GetErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Handle)>>(
          'Dart_GetError');
  late final _Dart_GetError =
      _Dart_GetErrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(Object)>();

  /// Is this an error handle for an unhandled exception?
  bool Dart_ErrorHasException(
    Object handle,
  ) {
    return _Dart_ErrorHasException(
      handle,
    );
  }

  late final _Dart_ErrorHasExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_ErrorHasException');
  late final _Dart_ErrorHasException =
      _Dart_ErrorHasExceptionPtr.asFunction<bool Function(Object)>();

  /// Gets the exception Object from an unhandled exception error handle.
  Object Dart_ErrorGetException(
    Object handle,
  ) {
    return _Dart_ErrorGetException(
      handle,
    );
  }

  late final _Dart_ErrorGetExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ErrorGetException');
  late final _Dart_ErrorGetException =
      _Dart_ErrorGetExceptionPtr.asFunction<Object Function(Object)>();

  /// Gets the stack trace Object from an unhandled exception error handle.
  Object Dart_ErrorGetStackTrace(
    Object handle,
  ) {
    return _Dart_ErrorGetStackTrace(
      handle,
    );
  }

  late final _Dart_ErrorGetStackTracePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ErrorGetStackTrace');
  late final _Dart_ErrorGetStackTrace =
      _Dart_ErrorGetStackTracePtr.asFunction<Object Function(Object)>();

  /// Produces an api error handle with the provided error message.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param error the error message.
  Object Dart_NewApiError(
    ffi.Pointer<ffi.Char> error,
  ) {
    return _Dart_NewApiError(
      error,
    );
  }

  late final _Dart_NewApiErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewApiError');
  late final _Dart_NewApiError =
      _Dart_NewApiErrorPtr.asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  Object Dart_NewCompilationError(
    ffi.Pointer<ffi.Char> error,
  ) {
    return _Dart_NewCompilationError(
      error,
    );
  }

  late final _Dart_NewCompilationErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewCompilationError');
  late final _Dart_NewCompilationError = _Dart_NewCompilationErrorPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  /// Produces a new unhandled exception error handle.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param exception An instance of a Dart object to be thrown or
  /// an ApiError or CompilationError handle.
  /// When an ApiError or CompilationError handle is passed in
  /// a string object of the error message is created and it becomes
  /// the Dart object to be thrown.
  Object Dart_NewUnhandledExceptionError(
    Object exception,
  ) {
    return _Dart_NewUnhandledExceptionError(
      exception,
    );
  }

  late final _Dart_NewUnhandledExceptionErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_NewUnhandledExceptionError');
  late final _Dart_NewUnhandledExceptionError =
      _Dart_NewUnhandledExceptionErrorPtr.asFunction<Object Function(Object)>();

  /// Propagates an error.
  ///
  /// If the provided handle is an unhandled exception error, this
  /// function will cause the unhandled exception to be rethrown.  This
  /// will proceed in the standard way, walking up Dart frames until an
  /// appropriate 'catch' block is found, executing 'finally' blocks,
  /// etc.
  ///
  /// If the error is not an unhandled exception error, we will unwind
  /// the stack to the next C frame.  Intervening Dart frames will be
  /// discarded; specifically, 'finally' blocks will not execute.  This
  /// is the standard way that compilation errors (and the like) are
  /// handled by the Dart runtime.
  ///
  /// In either case, when an error is propagated any current scopes
  /// created by Dart_EnterScope will be exited.
  ///
  /// See the additional discussion under "Propagating Errors" at the
  /// beginning of this file.
  ///
  /// \param handle An error handle (See Dart_IsError)
  ///
  /// On success, this function does not return.  On failure, the
  /// process is terminated.
  void Dart_PropagateError(
    Object handle,
  ) {
    return _Dart_PropagateError(
      handle,
    );
  }

  late final _Dart_PropagateErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>(
          'Dart_PropagateError');
  late final _Dart_PropagateError =
      _Dart_PropagateErrorPtr.asFunction<void Function(Object)>();

  /// Converts an object to a string.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \return The converted string if no error occurs during
  /// the conversion. If an error does occur, an error handle is
  /// returned.
  Object Dart_ToString(
    Object object,
  ) {
    return _Dart_ToString(
      object,
    );
  }

  late final _Dart_ToStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ToString');
  late final _Dart_ToString =
      _Dart_ToStringPtr.asFunction<Object Function(Object)>();

  /// Checks to see if two handles refer to identically equal objects.
  ///
  /// If both handles refer to instances, this is equivalent to using the top-level
  /// function identical() from dart:core. Otherwise, returns whether the two
  /// argument handles refer to the same object.
  ///
  /// \param obj1 An object to be compared.
  /// \param obj2 An object to be compared.
  ///
  /// \return True if the objects are identically equal.  False otherwise.
  bool Dart_IdentityEquals(
    Object obj1,
    Object obj2,
  ) {
    return _Dart_IdentityEquals(
      obj1,
      obj2,
    );
  }

  late final _Dart_IdentityEqualsPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle, ffi.Handle)>>(
          'Dart_IdentityEquals');
  late final _Dart_IdentityEquals =
      _Dart_IdentityEqualsPtr.asFunction<bool Function(Object, Object)>();

  /// Allocates a handle in the current scope from a persistent handle.
  Object Dart_HandleFromPersistent(
    Object object,
  ) {
    return _Dart_HandleFromPersistent(
      object,
    );
  }

  late final _Dart_HandleFromPersistentPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_HandleFromPersistent');
  late final _Dart_HandleFromPersistent =
      _Dart_HandleFromPersistentPtr.asFunction<Object Function(Object)>();

  /// Allocates a handle in the current scope from a weak persistent handle.
  ///
  /// This will be a handle to Dart_Null if the object has been garbage collected.
  Object Dart_HandleFromWeakPersistent(
    Dart_WeakPersistentHandle object,
  ) {
    return _Dart_HandleFromWeakPersistent(
      object,
    );
  }

  late final _Dart_HandleFromWeakPersistentPtr = _lookup<
          ffi.NativeFunction<ffi.Handle Function(Dart_WeakPersistentHandle)>>(
      'Dart_HandleFromWeakPersistent');
  late final _Dart_HandleFromWeakPersistent = _Dart_HandleFromWeakPersistentPtr
      .asFunction<Object Function(Dart_WeakPersistentHandle)>();

  /// Allocates a persistent handle for an object.
  ///
  /// This handle has the lifetime of the current isolate unless it is
  /// explicitly deallocated by calling Dart_DeletePersistentHandle.
  ///
  /// Requires there to be a current isolate.
  Object Dart_NewPersistentHandle(
    Object object,
  ) {
    return _Dart_NewPersistentHandle(
      object,
    );
  }

  late final _Dart_NewPersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_NewPersistentHandle');
  late final _Dart_NewPersistentHandle =
      _Dart_NewPersistentHandlePtr.asFunction<Object Function(Object)>();

  /// Assign value of local handle to a persistent handle.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param obj1 A persistent handle whose value needs to be set.
  /// \param obj2 An object whose value needs to be set to the persistent handle.
  void Dart_SetPersistentHandle(
    Object obj1,
    Object obj2,
  ) {
    return _Dart_SetPersistentHandle(
      obj1,
      obj2,
    );
  }

  late final _Dart_SetPersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle, ffi.Handle)>>(
          'Dart_SetPersistentHandle');
  late final _Dart_SetPersistentHandle =
      _Dart_SetPersistentHandlePtr.asFunction<void Function(Object, Object)>();

  /// Deallocates a persistent handle.
  ///
  /// Requires there to be a current isolate group.
  void Dart_DeletePersistentHandle(
    Object object,
  ) {
    return _Dart_DeletePersistentHandle(
      object,
    );
  }

  late final _Dart_DeletePersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>(
          'Dart_DeletePersistentHandle');
  late final _Dart_DeletePersistentHandle =
      _Dart_DeletePersistentHandlePtr.asFunction<void Function(Object)>();

  /// Allocates a weak persistent handle for an object.
  ///
  /// This handle has the lifetime of the current isolate. The handle can also be
  /// explicitly deallocated by calling Dart_DeleteWeakPersistentHandle.
  ///
  /// If the object becomes unreachable the callback is invoked with the peer as
  /// argument. The callback can be executed on any thread, will have a current
  /// isolate group, but will not have a current isolate. The callback can only
  /// call Dart_DeletePersistentHandle or Dart_DeleteWeakPersistentHandle. This
  /// gives the embedder the ability to cleanup data associated with the object.
  /// The handle will point to the Dart_Null object after the finalizer has been
  /// run. It is illegal to call into the VM with any other Dart_* functions from
  /// the callback. If the handle is deleted before the object becomes
  /// unreachable, the callback is never invoked.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param object An object with identity.
  /// \param peer A pointer to a native object or NULL.  This value is
  /// provided to callback when it is invoked.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A function pointer that will be invoked sometime
  /// after the object is garbage collected, unless the handle has been deleted.
  /// A valid callback needs to be specified it cannot be NULL.
  ///
  /// \return The weak persistent handle or NULL. NULL is returned in case of bad
  /// parameters.
  Dart_WeakPersistentHandle Dart_NewWeakPersistentHandle(
    Object object,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewWeakPersistentHandle(
      object,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewWeakPersistentHandlePtr = _lookup<
      ffi.NativeFunction<
          Dart_WeakPersistentHandle Function(
              ffi.Handle,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>>('Dart_NewWeakPersistentHandle');
  late final _Dart_NewWeakPersistentHandle =
      _Dart_NewWeakPersistentHandlePtr.asFunction<
          Dart_WeakPersistentHandle Function(
              Object, ffi.Pointer<ffi.Void>, int, Dart_HandleFinalizer)>();

  /// Deletes the given weak persistent [object] handle.
  ///
  /// Requires there to be a current isolate group.
  void Dart_DeleteWeakPersistentHandle(
    Dart_WeakPersistentHandle object,
  ) {
    return _Dart_DeleteWeakPersistentHandle(
      object,
    );
  }

  late final _Dart_DeleteWeakPersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Dart_WeakPersistentHandle)>>(
          'Dart_DeleteWeakPersistentHandle');
  late final _Dart_DeleteWeakPersistentHandle =
      _Dart_DeleteWeakPersistentHandlePtr.asFunction<
          void Function(Dart_WeakPersistentHandle)>();

  /// Allocates a finalizable handle for an object.
  ///
  /// This handle has the lifetime of the current isolate group unless the object
  /// pointed to by the handle is garbage collected, in this case the VM
  /// automatically deletes the handle after invoking the callback associated
  /// with the handle. The handle can also be explicitly deallocated by
  /// calling Dart_DeleteFinalizableHandle.
  ///
  /// If the object becomes unreachable the callback is invoked with the
  /// the peer as argument. The callback can be executed on any thread, will have
  /// an isolate group, but will not have a current isolate. The callback can only
  /// call Dart_DeletePersistentHandle or Dart_DeleteWeakPersistentHandle.
  /// This gives the embedder the ability to cleanup data associated with the
  /// object and clear out any cached references to the handle. All references to
  /// this handle after the callback will be invalid. It is illegal to call into
  /// the VM with any other Dart_* functions from the callback. If the handle is
  /// deleted before the object becomes unreachable, the callback is never
  /// invoked.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param object An object with identity.
  /// \param peer A pointer to a native object or NULL.  This value is
  /// provided to callback when it is invoked.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A function pointer that will be invoked sometime
  /// after the object is garbage collected, unless the handle has been deleted.
  /// A valid callback needs to be specified it cannot be NULL.
  ///
  /// \return The finalizable handle or NULL. NULL is returned in case of bad
  /// parameters.
  Dart_FinalizableHandle Dart_NewFinalizableHandle(
    Object object,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewFinalizableHandle(
      object,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewFinalizableHandlePtr = _lookup<
      ffi.NativeFunction<
          Dart_FinalizableHandle Function(ffi.Handle, ffi.Pointer<ffi.Void>,
              ffi.IntPtr, Dart_HandleFinalizer)>>('Dart_NewFinalizableHandle');
  late final _Dart_NewFinalizableHandle =
      _Dart_NewFinalizableHandlePtr.asFunction<
          Dart_FinalizableHandle Function(
              Object, ffi.Pointer<ffi.Void>, int, Dart_HandleFinalizer)>();

  /// Deletes the given finalizable [object] handle.
  ///
  /// The caller has to provide the actual Dart object the handle was created from
  /// to prove the object (and therefore the finalizable handle) is still alive.
  ///
  /// Requires there to be a current isolate.
  void Dart_DeleteFinalizableHandle(
    Dart_FinalizableHandle object,
    Object strong_ref_to_object,
  ) {
    return _Dart_DeleteFinalizableHandle(
      object,
      strong_ref_to_object,
    );
  }

  late final _Dart_DeleteFinalizableHandlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Dart_FinalizableHandle,
              ffi.Handle)>>('Dart_DeleteFinalizableHandle');
  late final _Dart_DeleteFinalizableHandle = _Dart_DeleteFinalizableHandlePtr
      .asFunction<void Function(Dart_FinalizableHandle, Object)>();

  /// Gets the version string for the Dart VM.
  ///
  /// The version of the Dart VM can be accessed without initializing the VM.
  ///
  /// \return The version string for the embedded Dart VM.
  ffi.Pointer<ffi.Char> Dart_VersionString() {
    return _Dart_VersionString();
  }

  late final _Dart_VersionStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'Dart_VersionString');
  late final _Dart_VersionString =
      _Dart_VersionStringPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Initialize Dart_IsolateFlags with correct version and default values.
  void Dart_IsolateFlagsInitialize(
    ffi.Pointer<Dart_IsolateFlags> flags,
  ) {
    return _Dart_IsolateFlagsInitialize(
      flags,
    );
  }

  late final _Dart_IsolateFlagsInitializePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<Dart_IsolateFlags>)>>(
      'Dart_IsolateFlagsInitialize');
  late final _Dart_IsolateFlagsInitialize = _Dart_IsolateFlagsInitializePtr
      .asFunction<void Function(ffi.Pointer<Dart_IsolateFlags>)>();

  /// Initializes the VM.
  ///
  /// \param params A struct containing initialization information. The version
  /// field of the struct must be DART_INITIALIZE_PARAMS_CURRENT_VERSION.
  ///
  /// \return NULL if initialization is successful. Returns an error message
  /// otherwise. The caller is responsible for freeing the error message.
  ffi.Pointer<ffi.Char> Dart_Initialize(
    ffi.Pointer<Dart_InitializeParams> params,
  ) {
    return _Dart_Initialize(
      params,
    );
  }

  late final _Dart_InitializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Dart_InitializeParams>)>>('Dart_Initialize');
  late final _Dart_Initialize = _Dart_InitializePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<Dart_InitializeParams>)>();

  /// Cleanup state in the VM before process termination.
  ///
  /// \return NULL if cleanup is successful. Returns an error message otherwise.
  /// The caller is responsible for freeing the error message.
  ///
  /// NOTE: This function must not be called on a thread that was created by the VM
  /// itself.
  ffi.Pointer<ffi.Char> Dart_Cleanup() {
    return _Dart_Cleanup();
  }

  late final _Dart_CleanupPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'Dart_Cleanup');
  late final _Dart_Cleanup =
      _Dart_CleanupPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Sets command line flags. Should be called before Dart_Initialize.
  ///
  /// \param argc The length of the arguments array.
  /// \param argv An array of arguments.
  ///
  /// \return NULL if successful. Returns an error message otherwise.
  /// The caller is responsible for freeing the error message.
  ///
  /// NOTE: This call does not store references to the passed in c-strings.
  ffi.Pointer<ffi.Char> Dart_SetVMFlags(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> argv,
  ) {
    return _Dart_SetVMFlags(
      argc,
      argv,
    );
  }

  late final _Dart_SetVMFlagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_SetVMFlags');
  late final _Dart_SetVMFlags = _Dart_SetVMFlagsPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Returns true if the named VM flag is of boolean type, specified, and set to
  /// true.
  ///
  /// \param flag_name The name of the flag without leading punctuation
  /// (example: "enable_asserts").
  bool Dart_IsVMFlagSet(
    ffi.Pointer<ffi.Char> flag_name,
  ) {
    return _Dart_IsVMFlagSet(
      flag_name,
    );
  }

  late final _Dart_IsVMFlagSetPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_IsVMFlagSet');
  late final _Dart_IsVMFlagSet =
      _Dart_IsVMFlagSetPtr.asFunction<bool Function(ffi.Pointer<ffi.Char>)>();

  /// Creates a new isolate. The new isolate becomes the current isolate.
  ///
  /// A snapshot can be used to restore the VM quickly to a saved state
  /// and is useful for fast startup. If snapshot data is provided, the
  /// isolate will be started using that snapshot data. Requires a core snapshot or
  /// an app snapshot created by Dart_CreateSnapshot or
  /// Dart_CreatePrecompiledSnapshot* from a VM with the same version.
  ///
  /// Requires there to be no current isolate.
  ///
  /// \param script_uri The main source file or snapshot this isolate will load.
  /// The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a
  /// child isolate is created by Isolate.spawn. The embedder should use a URI
  /// that allows it to load the same program into such a child isolate.
  /// \param name A short name for the isolate to improve debugging messages.
  /// Typically of the format 'foo.dart:main()'.
  /// \param isolate_snapshot_data Buffer containing the snapshot data of the
  /// isolate or NULL if no snapshot is provided. If provided, the buffer must
  /// remain valid until the isolate shuts down.
  /// \param isolate_snapshot_instructions Buffer containing the snapshot
  /// instructions of the isolate or NULL if no snapshot is provided. If
  /// provided, the buffer must remain valid until the isolate shuts down.
  /// \param flags Pointer to VM specific flags or NULL for default flags.
  /// \param isolate_group_data Embedder group data. This data can be obtained
  /// by calling Dart_IsolateGroupData and will be passed to the
  /// Dart_IsolateShutdownCallback, Dart_IsolateCleanupCallback, and
  /// Dart_IsolateGroupCleanupCallback.
  /// \param isolate_data Embedder data.  This data will be passed to
  /// the Dart_IsolateGroupCreateCallback when new isolates are spawned from
  /// this parent isolate.
  /// \param error Returns NULL if creation is successful, an error message
  /// otherwise. The caller is responsible for calling free() on the error
  /// message.
  ///
  /// \return The new isolate on success, or NULL if isolate creation failed.
  Dart_Isolate Dart_CreateIsolateGroup(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Uint8> isolate_snapshot_data,
    ffi.Pointer<ffi.Uint8> isolate_snapshot_instructions,
    ffi.Pointer<Dart_IsolateFlags> flags,
    ffi.Pointer<ffi.Void> isolate_group_data,
    ffi.Pointer<ffi.Void> isolate_data,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_CreateIsolateGroup(
      script_uri,
      name,
      isolate_snapshot_data,
      isolate_snapshot_instructions,
      flags,
      isolate_group_data,
      isolate_data,
      error,
    );
  }

  late final _Dart_CreateIsolateGroupPtr = _lookup<
      ffi.NativeFunction<
          Dart_Isolate Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<Dart_IsolateFlags>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_CreateIsolateGroup');
  late final _Dart_CreateIsolateGroup = _Dart_CreateIsolateGroupPtr.asFunction<
      Dart_Isolate Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<Dart_IsolateFlags>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Creates a new isolate inside the isolate group of [group_member].
  ///
  /// Requires there to be no current isolate.
  ///
  /// \param group_member An isolate from the same group into which the newly created
  /// isolate should be born into. Other threads may not have entered / enter this
  /// member isolate.
  /// \param name A short name for the isolate for debugging purposes.
  /// \param shutdown_callback A callback to be called when the isolate is being
  /// shutdown (may be NULL).
  /// \param cleanup_callback A callback to be called when the isolate is being
  /// cleaned up (may be NULL).
  /// \param child_isolate_data The embedder-specific data associated with this isolate.
  /// \param error Set to NULL if creation is successful, set to an error
  /// message otherwise. The caller is responsible for calling free() on the
  /// error message.
  ///
  /// \return The newly created isolate on success, or NULL if isolate creation
  /// failed.
  ///
  /// If successful, the newly created isolate will become the current isolate.
  Dart_Isolate Dart_CreateIsolateInGroup(
    Dart_Isolate group_member,
    ffi.Pointer<ffi.Char> name,
    Dart_IsolateShutdownCallback shutdown_callback,
    Dart_IsolateCleanupCallback cleanup_callback,
    ffi.Pointer<ffi.Void> child_isolate_data,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_CreateIsolateInGroup(
      group_member,
      name,
      shutdown_callback,
      cleanup_callback,
      child_isolate_data,
      error,
    );
  }

  late final _Dart_CreateIsolateInGroupPtr = _lookup<
          ffi.NativeFunction<
              Dart_Isolate Function(
                  Dart_Isolate,
                  ffi.Pointer<ffi.Char>,
                  Dart_IsolateShutdownCallback,
                  Dart_IsolateCleanupCallback,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'Dart_CreateIsolateInGroup');
  late final _Dart_CreateIsolateInGroup =
      _Dart_CreateIsolateInGroupPtr.asFunction<
          Dart_Isolate Function(
              Dart_Isolate,
              ffi.Pointer<ffi.Char>,
              Dart_IsolateShutdownCallback,
              Dart_IsolateCleanupCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Creates a new isolate from a Dart Kernel file. The new isolate
  /// becomes the current isolate.
  ///
  /// Requires there to be no current isolate.
  ///
  /// \param script_uri The main source file or snapshot this isolate will load.
  /// The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a
  /// child isolate is created by Isolate.spawn. The embedder should use a URI that
  /// allows it to load the same program into such a child isolate.
  /// \param name A short name for the isolate to improve debugging messages.
  /// Typically of the format 'foo.dart:main()'.
  /// \param kernel_buffer A buffer which contains a kernel/DIL program. Must
  /// remain valid until isolate shutdown.
  /// \param kernel_buffer_size The size of `kernel_buffer`.
  /// \param flags Pointer to VM specific flags or NULL for default flags.
  /// \param isolate_group_data Embedder group data. This data can be obtained
  /// by calling Dart_IsolateGroupData and will be passed to the
  /// Dart_IsolateShutdownCallback, Dart_IsolateCleanupCallback, and
  /// Dart_IsolateGroupCleanupCallback.
  /// \param isolate_data Embedder data.  This data will be passed to
  /// the Dart_IsolateGroupCreateCallback when new isolates are spawned from
  /// this parent isolate.
  /// \param error Returns NULL if creation is successful, an error message
  /// otherwise. The caller is responsible for calling free() on the error
  /// message.
  ///
  /// \return The new isolate on success, or NULL if isolate creation failed.
  Dart_Isolate Dart_CreateIsolateGroupFromKernel(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_buffer_size,
    ffi.Pointer<Dart_IsolateFlags> flags,
    ffi.Pointer<ffi.Void> isolate_group_data,
    ffi.Pointer<ffi.Void> isolate_data,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_CreateIsolateGroupFromKernel(
      script_uri,
      name,
      kernel_buffer,
      kernel_buffer_size,
      flags,
      isolate_group_data,
      isolate_data,
      error,
    );
  }

  late final _Dart_CreateIsolateGroupFromKernelPtr = _lookup<
          ffi.NativeFunction<
              Dart_Isolate Function(
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Uint8>,
                  ffi.IntPtr,
                  ffi.Pointer<Dart_IsolateFlags>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'Dart_CreateIsolateGroupFromKernel');
  late final _Dart_CreateIsolateGroupFromKernel =
      _Dart_CreateIsolateGroupFromKernelPtr.asFunction<
          Dart_Isolate Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              int,
              ffi.Pointer<Dart_IsolateFlags>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Shuts down the current isolate. After this call, the current isolate is NULL.
  /// Any current scopes created by Dart_EnterScope will be exited. Invokes the
  /// shutdown callback and any callbacks of remaining weak persistent handles.
  ///
  /// Requires there to be a current isolate.
  void Dart_ShutdownIsolate() {
    return _Dart_ShutdownIsolate();
  }

  late final _Dart_ShutdownIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_ShutdownIsolate');
  late final _Dart_ShutdownIsolate =
      _Dart_ShutdownIsolatePtr.asFunction<void Function()>();

  /// Returns the current isolate. Will return NULL if there is no
  /// current isolate.
  Dart_Isolate Dart_CurrentIsolate() {
    return _Dart_CurrentIsolate();
  }

  late final _Dart_CurrentIsolatePtr =
      _lookup<ffi.NativeFunction<Dart_Isolate Function()>>(
          'Dart_CurrentIsolate');
  late final _Dart_CurrentIsolate =
      _Dart_CurrentIsolatePtr.asFunction<Dart_Isolate Function()>();

  /// Returns the callback data associated with the current isolate. This
  /// data was set when the isolate got created or initialized.
  ffi.Pointer<ffi.Void> Dart_CurrentIsolateData() {
    return _Dart_CurrentIsolateData();
  }

  late final _Dart_CurrentIsolateDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
          'Dart_CurrentIsolateData');
  late final _Dart_CurrentIsolateData = _Dart_CurrentIsolateDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function()>();

  /// Returns the callback data associated with the given isolate. This
  /// data was set when the isolate got created or initialized.
  ffi.Pointer<ffi.Void> Dart_IsolateData(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateData(
      isolate,
    );
  }

  late final _Dart_IsolateDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(Dart_Isolate)>>(
          'Dart_IsolateData');
  late final _Dart_IsolateData = _Dart_IsolateDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(Dart_Isolate)>();

  /// Returns the current isolate group. Will return NULL if there is no
  /// current isolate group.
  Dart_IsolateGroup Dart_CurrentIsolateGroup() {
    return _Dart_CurrentIsolateGroup();
  }

  late final _Dart_CurrentIsolateGroupPtr =
      _lookup<ffi.NativeFunction<Dart_IsolateGroup Function()>>(
          'Dart_CurrentIsolateGroup');
  late final _Dart_CurrentIsolateGroup =
      _Dart_CurrentIsolateGroupPtr.asFunction<Dart_IsolateGroup Function()>();

  /// Returns the callback data associated with the current isolate group. This
  /// data was passed to the isolate group when it was created.
  ffi.Pointer<ffi.Void> Dart_CurrentIsolateGroupData() {
    return _Dart_CurrentIsolateGroupData();
  }

  late final _Dart_CurrentIsolateGroupDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
          'Dart_CurrentIsolateGroupData');
  late final _Dart_CurrentIsolateGroupData = _Dart_CurrentIsolateGroupDataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function()>();

  int Dart_CurrentIsolateGroupId() {
    return _Dart_CurrentIsolateGroupId();
  }

  late final _Dart_CurrentIsolateGroupIdPtr =
      _lookup<ffi.NativeFunction<Dart_IsolateGroupId Function()>>(
          'Dart_CurrentIsolateGroupId');
  late final _Dart_CurrentIsolateGroupId =
      _Dart_CurrentIsolateGroupIdPtr.asFunction<int Function()>();

  /// Returns the callback data associated with the specified isolate group. This
  /// data was passed to the isolate when it was created.
  /// The embedder is responsible for ensuring the consistency of this data
  /// with respect to the lifecycle of an isolate group.
  ffi.Pointer<ffi.Void> Dart_IsolateGroupData(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateGroupData(
      isolate,
    );
  }

  late final _Dart_IsolateGroupDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(Dart_Isolate)>>(
          'Dart_IsolateGroupData');
  late final _Dart_IsolateGroupData = _Dart_IsolateGroupDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(Dart_Isolate)>();

  /// Returns the debugging name for the current isolate.
  ///
  /// This name is unique to each isolate and should only be used to make
  /// debugging messages more comprehensible.
  Object Dart_DebugName() {
    return _Dart_DebugName();
  }

  late final _Dart_DebugNamePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_DebugName');
  late final _Dart_DebugName =
      _Dart_DebugNamePtr.asFunction<Object Function()>();

  /// Returns the debugging name for the current isolate.
  ///
  /// This name is unique to each isolate and should only be used to make
  /// debugging messages more comprehensible.
  ///
  /// The returned string is scope allocated and is only valid until the next call
  /// to Dart_ExitScope.
  ffi.Pointer<ffi.Char> Dart_DebugNameToCString() {
    return _Dart_DebugNameToCString();
  }

  late final _Dart_DebugNameToCStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'Dart_DebugNameToCString');
  late final _Dart_DebugNameToCString = _Dart_DebugNameToCStringPtr.asFunction<
      ffi.Pointer<ffi.Char> Function()>();

  /// Returns the ID for an isolate which is used to query the service protocol.
  ///
  /// It is the responsibility of the caller to free the returned ID.
  ffi.Pointer<ffi.Char> Dart_IsolateServiceId(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateServiceId(
      isolate,
    );
  }

  late final _Dart_IsolateServiceIdPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(Dart_Isolate)>>(
          'Dart_IsolateServiceId');
  late final _Dart_IsolateServiceId = _Dart_IsolateServiceIdPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(Dart_Isolate)>();

  /// Enters an isolate. After calling this function,
  /// the current isolate will be set to the provided isolate.
  ///
  /// Requires there to be no current isolate. Multiple threads may not be in
  /// the same isolate at once.
  void Dart_EnterIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_EnterIsolate(
      isolate,
    );
  }

  late final _Dart_EnterIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Dart_Isolate)>>(
          'Dart_EnterIsolate');
  late final _Dart_EnterIsolate =
      _Dart_EnterIsolatePtr.asFunction<void Function(Dart_Isolate)>();

  /// Kills the given isolate.
  ///
  /// This function has the same effect as dart:isolate's
  /// Isolate.kill(priority:immediate).
  /// It can interrupt ordinary Dart code but not native code. If the isolate is
  /// in the middle of a long running native function, the isolate will not be
  /// killed until control returns to Dart.
  ///
  /// Does not require a current isolate. It is safe to kill the current isolate if
  /// there is one.
  void Dart_KillIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_KillIsolate(
      isolate,
    );
  }

  late final _Dart_KillIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Dart_Isolate)>>(
          'Dart_KillIsolate');
  late final _Dart_KillIsolate =
      _Dart_KillIsolatePtr.asFunction<void Function(Dart_Isolate)>();

  /// Notifies the VM that the embedder expects to be idle until |deadline|. The VM
  /// may use this time to perform garbage collection or other tasks to avoid
  /// delays during execution of Dart code in the future.
  ///
  /// |deadline| is measured in microseconds against the system's monotonic time.
  /// This clock can be accessed via Dart_TimelineGetMicros().
  ///
  /// Requires there to be a current isolate.
  void Dart_NotifyIdle(
    int deadline,
  ) {
    return _Dart_NotifyIdle(
      deadline,
    );
  }

  late final _Dart_NotifyIdlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64)>>(
          'Dart_NotifyIdle');
  late final _Dart_NotifyIdle =
      _Dart_NotifyIdlePtr.asFunction<void Function(int)>();

  /// Starts the heap sampling profiler for each thread in the VM.
  void Dart_EnableHeapSampling() {
    return _Dart_EnableHeapSampling();
  }

  late final _Dart_EnableHeapSamplingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'Dart_EnableHeapSampling');
  late final _Dart_EnableHeapSampling =
      _Dart_EnableHeapSamplingPtr.asFunction<void Function()>();

  void Dart_DisableHeapSampling() {
    return _Dart_DisableHeapSampling();
  }

  late final _Dart_DisableHeapSamplingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'Dart_DisableHeapSampling');
  late final _Dart_DisableHeapSampling =
      _Dart_DisableHeapSamplingPtr.asFunction<void Function()>();

  void Dart_RegisterHeapSamplingCallback(
    Dart_HeapSamplingCreateCallback create_callback,
    Dart_HeapSamplingDeleteCallback delete_callback,
  ) {
    return _Dart_RegisterHeapSamplingCallback(
      create_callback,
      delete_callback,
    );
  }

  late final _Dart_RegisterHeapSamplingCallbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(Dart_HeapSamplingCreateCallback,
                  Dart_HeapSamplingDeleteCallback)>>(
      'Dart_RegisterHeapSamplingCallback');
  late final _Dart_RegisterHeapSamplingCallback =
      _Dart_RegisterHeapSamplingCallbackPtr.asFunction<
          void Function(Dart_HeapSamplingCreateCallback,
              Dart_HeapSamplingDeleteCallback)>();

  void Dart_ReportSurvivingAllocations(
    Dart_HeapSamplingReportCallback callback,
    ffi.Pointer<ffi.Void> context,
    bool force_gc,
  ) {
    return _Dart_ReportSurvivingAllocations(
      callback,
      context,
      force_gc,
    );
  }

  late final _Dart_ReportSurvivingAllocationsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Dart_HeapSamplingReportCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Bool)>>('Dart_ReportSurvivingAllocations');
  late final _Dart_ReportSurvivingAllocations =
      _Dart_ReportSurvivingAllocationsPtr.asFunction<
          void Function(
              Dart_HeapSamplingReportCallback, ffi.Pointer<ffi.Void>, bool)>();

  void Dart_SetHeapSamplingPeriod(
    int bytes,
  ) {
    return _Dart_SetHeapSamplingPeriod(
      bytes,
    );
  }

  late final _Dart_SetHeapSamplingPeriodPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.IntPtr)>>(
          'Dart_SetHeapSamplingPeriod');
  late final _Dart_SetHeapSamplingPeriod =
      _Dart_SetHeapSamplingPeriodPtr.asFunction<void Function(int)>();

  /// Notifies the VM that the embedder expects the application's working set has
  /// recently shrunk significantly and is not expected to rise in the near future.
  /// The VM may spend O(heap-size) time performing clean up work.
  ///
  /// Requires there to be a current isolate.
  void Dart_NotifyDestroyed() {
    return _Dart_NotifyDestroyed();
  }

  late final _Dart_NotifyDestroyedPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_NotifyDestroyed');
  late final _Dart_NotifyDestroyed =
      _Dart_NotifyDestroyedPtr.asFunction<void Function()>();

  /// Notifies the VM that the system is running low on memory.
  ///
  /// Does not require a current isolate. Only valid after calling Dart_Initialize.
  void Dart_NotifyLowMemory() {
    return _Dart_NotifyLowMemory();
  }

  late final _Dart_NotifyLowMemoryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_NotifyLowMemory');
  late final _Dart_NotifyLowMemory =
      _Dart_NotifyLowMemoryPtr.asFunction<void Function()>();

  /// Set the desired performance trade-off.
  ///
  /// Requires a current isolate.
  ///
  /// Returns the previous performance mode.
  Dart_PerformanceMode Dart_SetPerformanceMode(
    Dart_PerformanceMode mode,
  ) {
    return Dart_PerformanceMode.fromValue(_Dart_SetPerformanceMode(
      mode.value,
    ));
  }

  late final _Dart_SetPerformanceModePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'Dart_SetPerformanceMode');
  late final _Dart_SetPerformanceMode =
      _Dart_SetPerformanceModePtr.asFunction<int Function(int)>();

  /// Starts the CPU sampling profiler.
  void Dart_StartProfiling() {
    return _Dart_StartProfiling();
  }

  late final _Dart_StartProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_StartProfiling');
  late final _Dart_StartProfiling =
      _Dart_StartProfilingPtr.asFunction<void Function()>();

  /// Stops the CPU sampling profiler.
  ///
  /// Note that some profile samples might still be taken after this function
  /// returns due to the asynchronous nature of the implementation on some
  /// platforms.
  void Dart_StopProfiling() {
    return _Dart_StopProfiling();
  }

  late final _Dart_StopProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_StopProfiling');
  late final _Dart_StopProfiling =
      _Dart_StopProfilingPtr.asFunction<void Function()>();

  /// Notifies the VM that the current thread should not be profiled until a
  /// matching call to Dart_ThreadEnableProfiling is made.
  ///
  /// NOTE: By default, if a thread has entered an isolate it will be profiled.
  /// This function should be used when an embedder knows a thread is about
  /// to make a blocking call and wants to avoid unnecessary interrupts by
  /// the profiler.
  void Dart_ThreadDisableProfiling() {
    return _Dart_ThreadDisableProfiling();
  }

  late final _Dart_ThreadDisableProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'Dart_ThreadDisableProfiling');
  late final _Dart_ThreadDisableProfiling =
      _Dart_ThreadDisableProfilingPtr.asFunction<void Function()>();

  /// Notifies the VM that the current thread should be profiled.
  ///
  /// NOTE: It is only legal to call this function *after* calling
  /// Dart_ThreadDisableProfiling.
  ///
  /// NOTE: By default, if a thread has entered an isolate it will be profiled.
  void Dart_ThreadEnableProfiling() {
    return _Dart_ThreadEnableProfiling();
  }

  late final _Dart_ThreadEnableProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'Dart_ThreadEnableProfiling');
  late final _Dart_ThreadEnableProfiling =
      _Dart_ThreadEnableProfilingPtr.asFunction<void Function()>();

  /// Register symbol information for the Dart VM's profiler and crash dumps.
  ///
  /// This consumes the output of //topaz/runtime/dart/profiler_symbols, which
  /// should be treated as opaque.
  void Dart_AddSymbols(
    ffi.Pointer<ffi.Char> dso_name,
    ffi.Pointer<ffi.Void> buffer,
    int buffer_size,
  ) {
    return _Dart_AddSymbols(
      dso_name,
      buffer,
      buffer_size,
    );
  }

  late final _Dart_AddSymbolsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>,
              ffi.IntPtr)>>('Dart_AddSymbols');
  late final _Dart_AddSymbols = _Dart_AddSymbolsPtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>, int)>();

  /// Exits an isolate. After this call, Dart_CurrentIsolate will
  /// return NULL.
  ///
  /// Requires there to be a current isolate.
  void Dart_ExitIsolate() {
    return _Dart_ExitIsolate();
  }

  late final _Dart_ExitIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_ExitIsolate');
  late final _Dart_ExitIsolate =
      _Dart_ExitIsolatePtr.asFunction<void Function()>();

  /// Creates a full snapshot of the current isolate heap.
  ///
  /// A full snapshot is a compact representation of the dart vm isolate heap
  /// and dart isolate heap states. These snapshots are used to initialize
  /// the vm isolate on startup and fast initialization of an isolate.
  /// A Snapshot of the heap is created before any dart code has executed.
  ///
  /// Requires there to be a current isolate. Not available in the precompiled
  /// runtime (check Dart_IsPrecompiledRuntime).
  ///
  /// \param vm_snapshot_data_buffer Returns a pointer to a buffer containing the
  /// vm snapshot. This buffer is scope allocated and is only valid
  /// until the next call to Dart_ExitScope.
  /// \param vm_snapshot_data_size Returns the size of vm_snapshot_data_buffer.
  /// \param isolate_snapshot_data_buffer Returns a pointer to a buffer containing
  /// the isolate snapshot. This buffer is scope allocated and is only valid
  /// until the next call to Dart_ExitScope.
  /// \param isolate_snapshot_data_size Returns the size of
  /// isolate_snapshot_data_buffer.
  /// \param is_core Create a snapshot containing core libraries.
  /// Such snapshot should be agnostic to null safety mode.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateSnapshot(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> vm_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> vm_snapshot_data_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_data_size,
    bool is_core,
  ) {
    return _Dart_CreateSnapshot(
      vm_snapshot_data_buffer,
      vm_snapshot_data_size,
      isolate_snapshot_data_buffer,
      isolate_snapshot_data_size,
      is_core,
    );
  }

  late final _Dart_CreateSnapshotPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Bool)>>('Dart_CreateSnapshot');
  late final _Dart_CreateSnapshot = _Dart_CreateSnapshotPtr.asFunction<
      Object Function(
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.IntPtr>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.IntPtr>,
          bool)>();

  /// Returns whether the buffer contains a kernel file.
  ///
  /// \param buffer Pointer to a buffer that might contain a kernel binary.
  /// \param buffer_size Size of the buffer.
  ///
  /// \return Whether the buffer contains a kernel binary (full or partial).
  bool Dart_IsKernel(
    ffi.Pointer<ffi.Uint8> buffer,
    int buffer_size,
  ) {
    return _Dart_IsKernel(
      buffer,
      buffer_size,
    );
  }

  late final _Dart_IsKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>('Dart_IsKernel');
  late final _Dart_IsKernel = _Dart_IsKernelPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Make isolate runnable.
  ///
  /// When isolates are spawned, this function is used to indicate that
  /// the creation and initialization (including script loading) of the
  /// isolate is complete and the isolate can start.
  /// This function expects there to be no current isolate.
  ///
  /// \param isolate The isolate to be made runnable.
  ///
  /// \return NULL if successful. Returns an error message otherwise. The caller
  /// is responsible for freeing the error message.
  ffi.Pointer<ffi.Char> Dart_IsolateMakeRunnable(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateMakeRunnable(
      isolate,
    );
  }

  late final _Dart_IsolateMakeRunnablePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(Dart_Isolate)>>(
          'Dart_IsolateMakeRunnable');
  late final _Dart_IsolateMakeRunnable = _Dart_IsolateMakeRunnablePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(Dart_Isolate)>();

  /// Allows embedders to provide a custom wakeup mechanism for the delivery of
  /// inter-isolate messages. This setting only applies to the current isolate.
  ///
  /// This mechanism is optional: if not provided, the isolate will be scheduled on
  /// a VM-managed thread pool. An embedder should provide this callback if it
  /// wants to run an isolate on a specific thread or to interleave handling of
  /// inter-isolate messages with other event sources.
  ///
  /// Most embedders will only call this function once, before isolate
  /// execution begins. If this function is called after isolate
  /// execution begins, the embedder is responsible for threading issues.
  void Dart_SetMessageNotifyCallback(
    Dart_MessageNotifyCallback message_notify_callback,
  ) {
    return _Dart_SetMessageNotifyCallback(
      message_notify_callback,
    );
  }

  late final _Dart_SetMessageNotifyCallbackPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Dart_MessageNotifyCallback)>>(
      'Dart_SetMessageNotifyCallback');
  late final _Dart_SetMessageNotifyCallback = _Dart_SetMessageNotifyCallbackPtr
      .asFunction<void Function(Dart_MessageNotifyCallback)>();

  /// Query the current message notify callback for the isolate.
  ///
  /// \return The current message notify callback for the isolate.
  Dart_MessageNotifyCallback Dart_GetMessageNotifyCallback() {
    return _Dart_GetMessageNotifyCallback();
  }

  late final _Dart_GetMessageNotifyCallbackPtr =
      _lookup<ffi.NativeFunction<Dart_MessageNotifyCallback Function()>>(
          'Dart_GetMessageNotifyCallback');
  late final _Dart_GetMessageNotifyCallback = _Dart_GetMessageNotifyCallbackPtr
      .asFunction<Dart_MessageNotifyCallback Function()>();

  /// If the VM flag `--pause-isolates-on-start` was passed this will be true.
  ///
  /// \return A boolean value indicating if pause on start was requested.
  bool Dart_ShouldPauseOnStart() {
    return _Dart_ShouldPauseOnStart();
  }

  late final _Dart_ShouldPauseOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_ShouldPauseOnStart');
  late final _Dart_ShouldPauseOnStart =
      _Dart_ShouldPauseOnStartPtr.asFunction<bool Function()>();

  /// Override the VM flag `--pause-isolates-on-start` for the current isolate.
  ///
  /// \param should_pause Should the isolate be paused on start?
  ///
  /// NOTE: This must be called before Dart_IsolateMakeRunnable.
  void Dart_SetShouldPauseOnStart(
    bool should_pause,
  ) {
    return _Dart_SetShouldPauseOnStart(
      should_pause,
    );
  }

  late final _Dart_SetShouldPauseOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetShouldPauseOnStart');
  late final _Dart_SetShouldPauseOnStart =
      _Dart_SetShouldPauseOnStartPtr.asFunction<void Function(bool)>();

  /// Is the current isolate paused on start?
  ///
  /// \return A boolean value indicating if the isolate is paused on start.
  bool Dart_IsPausedOnStart() {
    return _Dart_IsPausedOnStart();
  }

  late final _Dart_IsPausedOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_IsPausedOnStart');
  late final _Dart_IsPausedOnStart =
      _Dart_IsPausedOnStartPtr.asFunction<bool Function()>();

  /// Called when the embedder has paused the current isolate on start and when
  /// the embedder has resumed the isolate.
  ///
  /// \param paused Is the isolate paused on start?
  void Dart_SetPausedOnStart(
    bool paused,
  ) {
    return _Dart_SetPausedOnStart(
      paused,
    );
  }

  late final _Dart_SetPausedOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetPausedOnStart');
  late final _Dart_SetPausedOnStart =
      _Dart_SetPausedOnStartPtr.asFunction<void Function(bool)>();

  /// If the VM flag `--pause-isolates-on-exit` was passed this will be true.
  ///
  /// \return A boolean value indicating if pause on exit was requested.
  bool Dart_ShouldPauseOnExit() {
    return _Dart_ShouldPauseOnExit();
  }

  late final _Dart_ShouldPauseOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_ShouldPauseOnExit');
  late final _Dart_ShouldPauseOnExit =
      _Dart_ShouldPauseOnExitPtr.asFunction<bool Function()>();

  /// Override the VM flag `--pause-isolates-on-exit` for the current isolate.
  ///
  /// \param should_pause Should the isolate be paused on exit?
  void Dart_SetShouldPauseOnExit(
    bool should_pause,
  ) {
    return _Dart_SetShouldPauseOnExit(
      should_pause,
    );
  }

  late final _Dart_SetShouldPauseOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetShouldPauseOnExit');
  late final _Dart_SetShouldPauseOnExit =
      _Dart_SetShouldPauseOnExitPtr.asFunction<void Function(bool)>();

  /// Is the current isolate paused on exit?
  ///
  /// \return A boolean value indicating if the isolate is paused on exit.
  bool Dart_IsPausedOnExit() {
    return _Dart_IsPausedOnExit();
  }

  late final _Dart_IsPausedOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_IsPausedOnExit');
  late final _Dart_IsPausedOnExit =
      _Dart_IsPausedOnExitPtr.asFunction<bool Function()>();

  /// Called when the embedder has paused the current isolate on exit and when
  /// the embedder has resumed the isolate.
  ///
  /// \param paused Is the isolate paused on exit?
  void Dart_SetPausedOnExit(
    bool paused,
  ) {
    return _Dart_SetPausedOnExit(
      paused,
    );
  }

  late final _Dart_SetPausedOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetPausedOnExit');
  late final _Dart_SetPausedOnExit =
      _Dart_SetPausedOnExitPtr.asFunction<void Function(bool)>();

  /// Called when the embedder has caught a top level unhandled exception error
  /// in the current isolate.
  ///
  /// NOTE: It is illegal to call this twice on the same isolate without first
  /// clearing the sticky error to null.
  ///
  /// \param error The unhandled exception error.
  void Dart_SetStickyError(
    Object error,
  ) {
    return _Dart_SetStickyError(
      error,
    );
  }

  late final _Dart_SetStickyErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>(
          'Dart_SetStickyError');
  late final _Dart_SetStickyError =
      _Dart_SetStickyErrorPtr.asFunction<void Function(Object)>();

  /// Does the current isolate have a sticky error?
  bool Dart_HasStickyError() {
    return _Dart_HasStickyError();
  }

  late final _Dart_HasStickyErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_HasStickyError');
  late final _Dart_HasStickyError =
      _Dart_HasStickyErrorPtr.asFunction<bool Function()>();

  /// Gets the sticky error for the current isolate.
  ///
  /// \return A handle to the sticky error object or null.
  Object Dart_GetStickyError() {
    return _Dart_GetStickyError();
  }

  late final _Dart_GetStickyErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_GetStickyError');
  late final _Dart_GetStickyError =
      _Dart_GetStickyErrorPtr.asFunction<Object Function()>();

  /// Handles the next pending message for the current isolate.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_HandleMessage() {
    return _Dart_HandleMessage();
  }

  late final _Dart_HandleMessagePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_HandleMessage');
  late final _Dart_HandleMessage =
      _Dart_HandleMessagePtr.asFunction<Object Function()>();

  /// Handles any pending messages for the vm service for the current
  /// isolate.
  ///
  /// This function may be used by an embedder at a breakpoint to avoid
  /// pausing the vm service.
  ///
  /// This function can indirectly cause the message notify callback to
  /// be called.
  ///
  /// \return true if the vm service requests the program resume
  /// execution, false otherwise
  bool Dart_HandleServiceMessages() {
    return _Dart_HandleServiceMessages();
  }

  late final _Dart_HandleServiceMessagesPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_HandleServiceMessages');
  late final _Dart_HandleServiceMessages =
      _Dart_HandleServiceMessagesPtr.asFunction<bool Function()>();

  /// Does the current isolate have pending service messages?
  ///
  /// \return true if the isolate has pending service messages, false otherwise.
  bool Dart_HasServiceMessages() {
    return _Dart_HasServiceMessages();
  }

  late final _Dart_HasServiceMessagesPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_HasServiceMessages');
  late final _Dart_HasServiceMessages =
      _Dart_HasServiceMessagesPtr.asFunction<bool Function()>();

  /// Processes any incoming messages for the current isolate.
  ///
  /// This function may only be used when the embedder has not provided
  /// an alternate message delivery mechanism with
  /// Dart_SetMessageCallbacks. It is provided for convenience.
  ///
  /// This function waits for incoming messages for the current
  /// isolate. As new messages arrive, they are handled using
  /// Dart_HandleMessage. The routine exits when all ports to the
  /// current isolate are closed.
  ///
  /// \return A valid handle if the run loop exited successfully.  If an
  /// exception or other error occurs while processing messages, an
  /// error handle is returned.
  Object Dart_RunLoop() {
    return _Dart_RunLoop();
  }

  late final _Dart_RunLoopPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_RunLoop');
  late final _Dart_RunLoop = _Dart_RunLoopPtr.asFunction<Object Function()>();

  /// Lets the VM run message processing for the isolate.
  ///
  /// This function expects there to a current isolate and the current isolate
  /// must not have an active api scope. The VM will take care of making the
  /// isolate runnable (if not already), handles its message loop and will take
  /// care of shutting the isolate down once it's done.
  ///
  /// \param errors_are_fatal Whether uncaught errors should be fatal.
  /// \param on_error_port A port to notify on uncaught errors (or ILLEGAL_PORT).
  /// \param on_exit_port A port to notify on exit (or ILLEGAL_PORT).
  /// \param error A non-NULL pointer which will hold an error message if the call
  /// fails. The error has to be free()ed by the caller.
  ///
  /// \return If successful the VM takes ownership of the isolate and takes care
  /// of its message loop. If not successful the caller retains ownership of the
  /// isolate.
  bool Dart_RunLoopAsync(
    bool errors_are_fatal,
    int on_error_port,
    int on_exit_port,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_RunLoopAsync(
      errors_are_fatal,
      on_error_port,
      on_exit_port,
      error,
    );
  }

  late final _Dart_RunLoopAsyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Bool, Dart_Port, Dart_Port,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_RunLoopAsync');
  late final _Dart_RunLoopAsync = _Dart_RunLoopAsyncPtr.asFunction<
      bool Function(bool, int, int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Gets the main port id for the current isolate.
  int Dart_GetMainPortId() {
    return _Dart_GetMainPortId();
  }

  late final _Dart_GetMainPortIdPtr =
      _lookup<ffi.NativeFunction<Dart_Port Function()>>('Dart_GetMainPortId');
  late final _Dart_GetMainPortId =
      _Dart_GetMainPortIdPtr.asFunction<int Function()>();

  /// Does the current isolate have live ReceivePorts?
  ///
  /// A ReceivePort is live when it has not been closed.
  bool Dart_HasLivePorts() {
    return _Dart_HasLivePorts();
  }

  late final _Dart_HasLivePortsPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_HasLivePorts');
  late final _Dart_HasLivePorts =
      _Dart_HasLivePortsPtr.asFunction<bool Function()>();

  /// Posts a message for some isolate. The message is a serialized
  /// object.
  ///
  /// Requires there to be a current isolate.
  ///
  /// For posting messages outside of an isolate see \ref Dart_PostCObject.
  ///
  /// \param port_id The destination port.
  /// \param object An object from the current isolate.
  ///
  /// \return True if the message was posted.
  bool Dart_Post(
    int port_id,
    Object object,
  ) {
    return _Dart_Post(
      port_id,
      object,
    );
  }

  late final _Dart_PostPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Port, ffi.Handle)>>(
          'Dart_Post');
  late final _Dart_Post =
      _Dart_PostPtr.asFunction<bool Function(int, Object)>();

  /// Returns a new SendPort with the provided port id.
  ///
  /// If there is a possibility of a port closing since port_id was acquired
  /// for a SendPort, one should use Dart_NewSendPortEx and
  /// Dart_SendPortGetIdEx.
  ///
  /// \param port_id The destination port.
  ///
  /// \return A new SendPort if no errors occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewSendPort(
    int port_id,
  ) {
    return _Dart_NewSendPort(
      port_id,
    );
  }

  late final _Dart_NewSendPortPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(Dart_Port)>>(
          'Dart_NewSendPort');
  late final _Dart_NewSendPort =
      _Dart_NewSendPortPtr.asFunction<Object Function(int)>();

  /// Returns a new SendPort with the provided port id and origin id.
  ///
  /// \param portex_id The destination composte port id.
  ///
  /// \return A new SendPort if no errors occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewSendPortEx(
    Dart_PortEx portex_id,
  ) {
    return _Dart_NewSendPortEx(
      portex_id,
    );
  }

  late final _Dart_NewSendPortExPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(Dart_PortEx)>>(
          'Dart_NewSendPortEx');
  late final _Dart_NewSendPortEx =
      _Dart_NewSendPortExPtr.asFunction<Object Function(Dart_PortEx)>();

  /// Gets the SendPort id for the provided SendPort.
  /// \param port A SendPort object whose id is desired.
  /// \param port_id Returns the id of the SendPort.
  /// \return Success if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_SendPortGetId(
    Object port,
    ffi.Pointer<Dart_Port> port_id,
  ) {
    return _Dart_SendPortGetId(
      port,
      port_id,
    );
  }

  late final _Dart_SendPortGetIdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<Dart_Port>)>>('Dart_SendPortGetId');
  late final _Dart_SendPortGetId = _Dart_SendPortGetIdPtr.asFunction<
      Object Function(Object, ffi.Pointer<Dart_Port>)>();

  /// Gets the SendPort and Origin ids for the provided SendPort.
  /// \param port A SendPort object whose id is desired.
  /// \param portex_id Returns composite id of the SendPort.
  /// \return Success if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_SendPortGetIdEx(
    Object port,
    ffi.Pointer<Dart_PortEx> portex_id,
  ) {
    return _Dart_SendPortGetIdEx(
      port,
      portex_id,
    );
  }

  late final _Dart_SendPortGetIdExPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<Dart_PortEx>)>>('Dart_SendPortGetIdEx');
  late final _Dart_SendPortGetIdEx = _Dart_SendPortGetIdExPtr.asFunction<
      Object Function(Object, ffi.Pointer<Dart_PortEx>)>();

  /// Sets the owner thread of the current isolate to be the current thread.
  ///
  /// Requires there to be a current isolate, and that the isolate is unowned.
  void Dart_SetCurrentThreadOwnsIsolate() {
    return _Dart_SetCurrentThreadOwnsIsolate();
  }

  late final _Dart_SetCurrentThreadOwnsIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'Dart_SetCurrentThreadOwnsIsolate');
  late final _Dart_SetCurrentThreadOwnsIsolate =
      _Dart_SetCurrentThreadOwnsIsolatePtr.asFunction<void Function()>();

  /// Returns whether the current thread owns the isolate that owns the given port.
  ///
  /// The port can be the isolate's main port, or any other port owned by the
  /// isolate.
  ///
  /// \param port_id The port to be checked.
  bool Dart_GetCurrentThreadOwnsIsolate(
    int port,
  ) {
    return _Dart_GetCurrentThreadOwnsIsolate(
      port,
    );
  }

  late final _Dart_GetCurrentThreadOwnsIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Port)>>(
          'Dart_GetCurrentThreadOwnsIsolate');
  late final _Dart_GetCurrentThreadOwnsIsolate =
      _Dart_GetCurrentThreadOwnsIsolatePtr.asFunction<bool Function(int)>();

  /// Enters a new scope.
  ///
  /// All new local handles will be created in this scope. Additionally,
  /// some functions may return "scope allocated" memory which is only
  /// valid within this scope.
  ///
  /// Requires there to be a current isolate.
  void Dart_EnterScope() {
    return _Dart_EnterScope();
  }

  late final _Dart_EnterScopePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_EnterScope');
  late final _Dart_EnterScope =
      _Dart_EnterScopePtr.asFunction<void Function()>();

  /// Exits a scope.
  ///
  /// The previous scope (if any) becomes the current scope.
  ///
  /// Requires there to be a current isolate.
  void Dart_ExitScope() {
    return _Dart_ExitScope();
  }

  late final _Dart_ExitScopePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_ExitScope');
  late final _Dart_ExitScope = _Dart_ExitScopePtr.asFunction<void Function()>();

  /// The Dart VM uses "zone allocation" for temporary structures. Zones
  /// support very fast allocation of small chunks of memory. The chunks
  /// cannot be deallocated individually, but instead zones support
  /// deallocating all chunks in one fast operation.
  ///
  /// This function makes it possible for the embedder to allocate
  /// temporary data in the VMs zone allocator.
  ///
  /// Zone allocation is possible:
  /// 1. when inside a scope where local handles can be allocated
  /// 2. when processing a message from a native port in a native port
  /// handler
  ///
  /// All the memory allocated this way will be reclaimed either on the
  /// next call to Dart_ExitScope or when the native port handler exits.
  ///
  /// \param size Size of the memory to allocate.
  ///
  /// \return A pointer to the allocated memory. NULL if allocation
  /// failed. Failure might due to is no current VM zone.
  ffi.Pointer<ffi.Uint8> Dart_ScopeAllocate(
    int size,
  ) {
    return _Dart_ScopeAllocate(
      size,
    );
  }

  late final _Dart_ScopeAllocatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Uint8> Function(ffi.IntPtr)>>(
          'Dart_ScopeAllocate');
  late final _Dart_ScopeAllocate =
      _Dart_ScopeAllocatePtr.asFunction<ffi.Pointer<ffi.Uint8> Function(int)>();

  /// Returns the null object.
  ///
  /// \return A handle to the null object.
  Object Dart_Null() {
    return _Dart_Null();
  }

  late final _Dart_NullPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_Null');
  late final _Dart_Null = _Dart_NullPtr.asFunction<Object Function()>();

  /// Is this object null?
  bool Dart_IsNull(
    Object object,
  ) {
    return _Dart_IsNull(
      object,
    );
  }

  late final _Dart_IsNullPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsNull');
  late final _Dart_IsNull = _Dart_IsNullPtr.asFunction<bool Function(Object)>();

  /// Returns the empty string object.
  ///
  /// \return A handle to the empty string object.
  Object Dart_EmptyString() {
    return _Dart_EmptyString();
  }

  late final _Dart_EmptyStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_EmptyString');
  late final _Dart_EmptyString =
      _Dart_EmptyStringPtr.asFunction<Object Function()>();

  /// Returns types that are not classes, and which therefore cannot be looked up
  /// as library members by Dart_GetType.
  ///
  /// \return A handle to the dynamic, void or Never type.
  Object Dart_TypeDynamic() {
    return _Dart_TypeDynamic();
  }

  late final _Dart_TypeDynamicPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_TypeDynamic');
  late final _Dart_TypeDynamic =
      _Dart_TypeDynamicPtr.asFunction<Object Function()>();

  Object Dart_TypeVoid() {
    return _Dart_TypeVoid();
  }

  late final _Dart_TypeVoidPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_TypeVoid');
  late final _Dart_TypeVoid = _Dart_TypeVoidPtr.asFunction<Object Function()>();

  Object Dart_TypeNever() {
    return _Dart_TypeNever();
  }

  late final _Dart_TypeNeverPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_TypeNever');
  late final _Dart_TypeNever =
      _Dart_TypeNeverPtr.asFunction<Object Function()>();

  /// Checks if the two objects are equal.
  ///
  /// The result of the comparison is returned through the 'equal'
  /// parameter. The return value itself is used to indicate success or
  /// failure, not equality.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param obj1 An object to be compared.
  /// \param obj2 An object to be compared.
  /// \param equal Returns the result of the equality comparison.
  ///
  /// \return A valid handle if no error occurs during the comparison.
  Object Dart_ObjectEquals(
    Object obj1,
    Object obj2,
    ffi.Pointer<ffi.Bool> equal,
  ) {
    return _Dart_ObjectEquals(
      obj1,
      obj2,
      equal,
    );
  }

  late final _Dart_ObjectEqualsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle,
              ffi.Pointer<ffi.Bool>)>>('Dart_ObjectEquals');
  late final _Dart_ObjectEquals = _Dart_ObjectEqualsPtr.asFunction<
      Object Function(Object, Object, ffi.Pointer<ffi.Bool>)>();

  /// Is this object an instance of some type?
  ///
  /// The result of the test is returned through the 'instanceof' parameter.
  /// The return value itself is used to indicate success or failure.
  ///
  /// \param object An object.
  /// \param type A type.
  /// \param instanceof Return true if 'object' is an instance of type 'type'.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_ObjectIsType(
    Object object,
    Object type,
    ffi.Pointer<ffi.Bool> instanceof,
  ) {
    return _Dart_ObjectIsType(
      object,
      type,
      instanceof,
    );
  }

  late final _Dart_ObjectIsTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle,
              ffi.Pointer<ffi.Bool>)>>('Dart_ObjectIsType');
  late final _Dart_ObjectIsType = _Dart_ObjectIsTypePtr.asFunction<
      Object Function(Object, Object, ffi.Pointer<ffi.Bool>)>();

  /// Query object type.
  ///
  /// \param object Some Object.
  ///
  /// \return true if Object is of the specified type.
  bool Dart_IsInstance(
    Object object,
  ) {
    return _Dart_IsInstance(
      object,
    );
  }

  late final _Dart_IsInstancePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsInstance');
  late final _Dart_IsInstance =
      _Dart_IsInstancePtr.asFunction<bool Function(Object)>();

  bool Dart_IsNumber(
    Object object,
  ) {
    return _Dart_IsNumber(
      object,
    );
  }

  late final _Dart_IsNumberPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsNumber');
  late final _Dart_IsNumber =
      _Dart_IsNumberPtr.asFunction<bool Function(Object)>();

  bool Dart_IsInteger(
    Object object,
  ) {
    return _Dart_IsInteger(
      object,
    );
  }

  late final _Dart_IsIntegerPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsInteger');
  late final _Dart_IsInteger =
      _Dart_IsIntegerPtr.asFunction<bool Function(Object)>();

  bool Dart_IsDouble(
    Object object,
  ) {
    return _Dart_IsDouble(
      object,
    );
  }

  late final _Dart_IsDoublePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsDouble');
  late final _Dart_IsDouble =
      _Dart_IsDoublePtr.asFunction<bool Function(Object)>();

  bool Dart_IsBoolean(
    Object object,
  ) {
    return _Dart_IsBoolean(
      object,
    );
  }

  late final _Dart_IsBooleanPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsBoolean');
  late final _Dart_IsBoolean =
      _Dart_IsBooleanPtr.asFunction<bool Function(Object)>();

  bool Dart_IsString(
    Object object,
  ) {
    return _Dart_IsString(
      object,
    );
  }

  late final _Dart_IsStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsString');
  late final _Dart_IsString =
      _Dart_IsStringPtr.asFunction<bool Function(Object)>();

  bool Dart_IsStringLatin1(
    Object object,
  ) {
    return _Dart_IsStringLatin1(
      object,
    );
  }

  late final _Dart_IsStringLatin1Ptr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsStringLatin1');
  late final _Dart_IsStringLatin1 =
      _Dart_IsStringLatin1Ptr.asFunction<bool Function(Object)>();

  bool Dart_IsList(
    Object object,
  ) {
    return _Dart_IsList(
      object,
    );
  }

  late final _Dart_IsListPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsList');
  late final _Dart_IsList = _Dart_IsListPtr.asFunction<bool Function(Object)>();

  bool Dart_IsMap(
    Object object,
  ) {
    return _Dart_IsMap(
      object,
    );
  }

  late final _Dart_IsMapPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsMap');
  late final _Dart_IsMap = _Dart_IsMapPtr.asFunction<bool Function(Object)>();

  bool Dart_IsLibrary(
    Object object,
  ) {
    return _Dart_IsLibrary(
      object,
    );
  }

  late final _Dart_IsLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsLibrary');
  late final _Dart_IsLibrary =
      _Dart_IsLibraryPtr.asFunction<bool Function(Object)>();

  bool Dart_IsType(
    Object handle,
  ) {
    return _Dart_IsType(
      handle,
    );
  }

  late final _Dart_IsTypePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsType');
  late final _Dart_IsType = _Dart_IsTypePtr.asFunction<bool Function(Object)>();

  bool Dart_IsFunction(
    Object handle,
  ) {
    return _Dart_IsFunction(
      handle,
    );
  }

  late final _Dart_IsFunctionPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsFunction');
  late final _Dart_IsFunction =
      _Dart_IsFunctionPtr.asFunction<bool Function(Object)>();

  bool Dart_IsVariable(
    Object handle,
  ) {
    return _Dart_IsVariable(
      handle,
    );
  }

  late final _Dart_IsVariablePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsVariable');
  late final _Dart_IsVariable =
      _Dart_IsVariablePtr.asFunction<bool Function(Object)>();

  bool Dart_IsTypeVariable(
    Object handle,
  ) {
    return _Dart_IsTypeVariable(
      handle,
    );
  }

  late final _Dart_IsTypeVariablePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsTypeVariable');
  late final _Dart_IsTypeVariable =
      _Dart_IsTypeVariablePtr.asFunction<bool Function(Object)>();

  bool Dart_IsClosure(
    Object object,
  ) {
    return _Dart_IsClosure(
      object,
    );
  }

  late final _Dart_IsClosurePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsClosure');
  late final _Dart_IsClosure =
      _Dart_IsClosurePtr.asFunction<bool Function(Object)>();

  bool Dart_IsTypedData(
    Object object,
  ) {
    return _Dart_IsTypedData(
      object,
    );
  }

  late final _Dart_IsTypedDataPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsTypedData');
  late final _Dart_IsTypedData =
      _Dart_IsTypedDataPtr.asFunction<bool Function(Object)>();

  bool Dart_IsByteBuffer(
    Object object,
  ) {
    return _Dart_IsByteBuffer(
      object,
    );
  }

  late final _Dart_IsByteBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsByteBuffer');
  late final _Dart_IsByteBuffer =
      _Dart_IsByteBufferPtr.asFunction<bool Function(Object)>();

  bool Dart_IsFuture(
    Object object,
  ) {
    return _Dart_IsFuture(
      object,
    );
  }

  late final _Dart_IsFuturePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsFuture');
  late final _Dart_IsFuture =
      _Dart_IsFuturePtr.asFunction<bool Function(Object)>();

  /// Gets the type of a Dart language object.
  ///
  /// \param instance Some Dart object.
  ///
  /// \return If no error occurs, the type is returned. Otherwise an
  /// error handle is returned.
  Object Dart_InstanceGetType(
    Object instance,
  ) {
    return _Dart_InstanceGetType(
      instance,
    );
  }

  late final _Dart_InstanceGetTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_InstanceGetType');
  late final _Dart_InstanceGetType =
      _Dart_InstanceGetTypePtr.asFunction<Object Function(Object)>();

  /// Returns the name for the provided class type.
  ///
  /// \return A valid string handle if no error occurs during the
  /// operation.
  Object Dart_ClassName(
    Object cls_type,
  ) {
    return _Dart_ClassName(
      cls_type,
    );
  }

  late final _Dart_ClassNamePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ClassName');
  late final _Dart_ClassName =
      _Dart_ClassNamePtr.asFunction<Object Function(Object)>();

  /// Returns the name for the provided function or method.
  ///
  /// \return A valid string handle if no error occurs during the
  /// operation.
  Object Dart_FunctionName(
    Object function,
  ) {
    return _Dart_FunctionName(
      function,
    );
  }

  late final _Dart_FunctionNamePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_FunctionName');
  late final _Dart_FunctionName =
      _Dart_FunctionNamePtr.asFunction<Object Function(Object)>();

  /// Returns a handle to the owner of a function.
  ///
  /// The owner of an instance method or a static method is its defining
  /// class. The owner of a top-level function is its defining
  /// library. The owner of the function of a non-implicit closure is the
  /// function of the method or closure that defines the non-implicit
  /// closure.
  ///
  /// \return A valid handle to the owner of the function, or an error
  /// handle if the argument is not a valid handle to a function.
  Object Dart_FunctionOwner(
    Object function,
  ) {
    return _Dart_FunctionOwner(
      function,
    );
  }

  late final _Dart_FunctionOwnerPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_FunctionOwner');
  late final _Dart_FunctionOwner =
      _Dart_FunctionOwnerPtr.asFunction<Object Function(Object)>();

  /// Determines whether a function handle refers to a static function
  /// of method.
  ///
  /// For the purposes of the embedding API, a top-level function is
  /// implicitly declared static.
  ///
  /// \param function A handle to a function or method declaration.
  /// \param is_static Returns whether the function or method is declared static.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_FunctionIsStatic(
    Object function,
    ffi.Pointer<ffi.Bool> is_static,
  ) {
    return _Dart_FunctionIsStatic(
      function,
      is_static,
    );
  }

  late final _Dart_FunctionIsStaticPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_FunctionIsStatic');
  late final _Dart_FunctionIsStatic = _Dart_FunctionIsStaticPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Is this object a closure resulting from a tear-off (closurized method)?
  ///
  /// Returns true for closures produced when an ordinary method is accessed
  /// through a getter call. Returns false otherwise, in particular for closures
  /// produced from local function declarations.
  ///
  /// \param object Some Object.
  ///
  /// \return true if Object is a tear-off.
  bool Dart_IsTearOff(
    Object object,
  ) {
    return _Dart_IsTearOff(
      object,
    );
  }

  late final _Dart_IsTearOffPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsTearOff');
  late final _Dart_IsTearOff =
      _Dart_IsTearOffPtr.asFunction<bool Function(Object)>();

  /// Retrieves the function of a closure.
  ///
  /// \return A handle to the function of the closure, or an error handle if the
  /// argument is not a closure.
  Object Dart_ClosureFunction(
    Object closure,
  ) {
    return _Dart_ClosureFunction(
      closure,
    );
  }

  late final _Dart_ClosureFunctionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ClosureFunction');
  late final _Dart_ClosureFunction =
      _Dart_ClosureFunctionPtr.asFunction<Object Function(Object)>();

  /// Returns a handle to the library which contains class.
  ///
  /// \return A valid handle to the library with owns class, null if the class
  /// has no library or an error handle if the argument is not a valid handle
  /// to a class type.
  Object Dart_ClassLibrary(
    Object cls_type,
  ) {
    return _Dart_ClassLibrary(
      cls_type,
    );
  }

  late final _Dart_ClassLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ClassLibrary');
  late final _Dart_ClassLibrary =
      _Dart_ClassLibraryPtr.asFunction<Object Function(Object)>();

  /// Does this Integer fit into a 64-bit signed integer?
  ///
  /// \param integer An integer.
  /// \param fits Returns true if the integer fits into a 64-bit signed integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerFitsIntoInt64(
    Object integer,
    ffi.Pointer<ffi.Bool> fits,
  ) {
    return _Dart_IntegerFitsIntoInt64(
      integer,
      fits,
    );
  }

  late final _Dart_IntegerFitsIntoInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_IntegerFitsIntoInt64');
  late final _Dart_IntegerFitsIntoInt64 = _Dart_IntegerFitsIntoInt64Ptr
      .asFunction<Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Does this Integer fit into a 64-bit unsigned integer?
  ///
  /// \param integer An integer.
  /// \param fits Returns true if the integer fits into a 64-bit unsigned integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerFitsIntoUint64(
    Object integer,
    ffi.Pointer<ffi.Bool> fits,
  ) {
    return _Dart_IntegerFitsIntoUint64(
      integer,
      fits,
    );
  }

  late final _Dart_IntegerFitsIntoUint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Bool>)>>('Dart_IntegerFitsIntoUint64');
  late final _Dart_IntegerFitsIntoUint64 = _Dart_IntegerFitsIntoUint64Ptr
      .asFunction<Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Returns an Integer with the provided value.
  ///
  /// \param value The value of the integer.
  ///
  /// \return The Integer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewInteger(
    int value,
  ) {
    return _Dart_NewInteger(
      value,
    );
  }

  late final _Dart_NewIntegerPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Int64)>>(
          'Dart_NewInteger');
  late final _Dart_NewInteger =
      _Dart_NewIntegerPtr.asFunction<Object Function(int)>();

  /// Returns an Integer with the provided value.
  ///
  /// \param value The unsigned value of the integer.
  ///
  /// \return The Integer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewIntegerFromUint64(
    int value,
  ) {
    return _Dart_NewIntegerFromUint64(
      value,
    );
  }

  late final _Dart_NewIntegerFromUint64Ptr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Uint64)>>(
          'Dart_NewIntegerFromUint64');
  late final _Dart_NewIntegerFromUint64 =
      _Dart_NewIntegerFromUint64Ptr.asFunction<Object Function(int)>();

  /// Returns an Integer with the provided value.
  ///
  /// \param value The value of the integer represented as a C string
  /// containing a hexadecimal number.
  ///
  /// \return The Integer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewIntegerFromHexCString(
    ffi.Pointer<ffi.Char> value,
  ) {
    return _Dart_NewIntegerFromHexCString(
      value,
    );
  }

  late final _Dart_NewIntegerFromHexCStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewIntegerFromHexCString');
  late final _Dart_NewIntegerFromHexCString = _Dart_NewIntegerFromHexCStringPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  /// Gets the value of an Integer.
  ///
  /// The integer must fit into a 64-bit signed integer, otherwise an error occurs.
  ///
  /// \param integer An Integer.
  /// \param value Returns the value of the Integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerToInt64(
    Object integer,
    ffi.Pointer<ffi.Int64> value,
  ) {
    return _Dart_IntegerToInt64(
      integer,
      value,
    );
  }

  late final _Dart_IntegerToInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Int64>)>>('Dart_IntegerToInt64');
  late final _Dart_IntegerToInt64 = _Dart_IntegerToInt64Ptr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Int64>)>();

  /// Gets the value of an Integer.
  ///
  /// The integer must fit into a 64-bit unsigned integer, otherwise an
  /// error occurs.
  ///
  /// \param integer An Integer.
  /// \param value Returns the value of the Integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerToUint64(
    Object integer,
    ffi.Pointer<ffi.Uint64> value,
  ) {
    return _Dart_IntegerToUint64(
      integer,
      value,
    );
  }

  late final _Dart_IntegerToUint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Uint64>)>>('Dart_IntegerToUint64');
  late final _Dart_IntegerToUint64 = _Dart_IntegerToUint64Ptr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Uint64>)>();

  /// Gets the value of an integer as a hexadecimal C string.
  ///
  /// \param integer An Integer.
  /// \param value Returns the value of the Integer as a hexadecimal C
  /// string. This C string is scope allocated and is only valid until
  /// the next call to Dart_ExitScope.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerToHexCString(
    Object integer,
    ffi.Pointer<ffi.Pointer<ffi.Char>> value,
  ) {
    return _Dart_IntegerToHexCString(
      integer,
      value,
    );
  }

  late final _Dart_IntegerToHexCStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_IntegerToHexCString');
  late final _Dart_IntegerToHexCString =
      _Dart_IntegerToHexCStringPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Returns a Double with the provided value.
  ///
  /// \param value A double.
  ///
  /// \return The Double object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewDouble(
    double value,
  ) {
    return _Dart_NewDouble(
      value,
    );
  }

  late final _Dart_NewDoublePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Double)>>(
          'Dart_NewDouble');
  late final _Dart_NewDouble =
      _Dart_NewDoublePtr.asFunction<Object Function(double)>();

  /// Gets the value of a Double
  ///
  /// \param double_obj A Double
  /// \param value Returns the value of the Double.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_DoubleValue(
    Object double_obj,
    ffi.Pointer<ffi.Double> value,
  ) {
    return _Dart_DoubleValue(
      double_obj,
      value,
    );
  }

  late final _Dart_DoubleValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Double>)>>('Dart_DoubleValue');
  late final _Dart_DoubleValue = _Dart_DoubleValuePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Double>)>();

  /// Returns a closure of static function 'function_name' in the class 'class_name'
  /// in the exported namespace of specified 'library'.
  ///
  /// \param library Library object
  /// \param cls_type Type object representing a Class
  /// \param function_name Name of the static function in the class
  ///
  /// \return A valid Dart instance if no error occurs during the operation.
  Object Dart_GetStaticMethodClosure(
    Object library$,
    Object cls_type,
    Object function_name,
  ) {
    return _Dart_GetStaticMethodClosure(
      library$,
      cls_type,
      function_name,
    );
  }

  late final _Dart_GetStaticMethodClosurePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle,
              ffi.Handle)>>('Dart_GetStaticMethodClosure');
  late final _Dart_GetStaticMethodClosure = _Dart_GetStaticMethodClosurePtr
      .asFunction<Object Function(Object, Object, Object)>();

  /// Returns the True object.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \return A handle to the True object.
  Object Dart_True() {
    return _Dart_True();
  }

  late final _Dart_TruePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_True');
  late final _Dart_True = _Dart_TruePtr.asFunction<Object Function()>();

  /// Returns the False object.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \return A handle to the False object.
  Object Dart_False() {
    return _Dart_False();
  }

  late final _Dart_FalsePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_False');
  late final _Dart_False = _Dart_FalsePtr.asFunction<Object Function()>();

  /// Returns a Boolean with the provided value.
  ///
  /// \param value true or false.
  ///
  /// \return The Boolean object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewBoolean(
    bool value,
  ) {
    return _Dart_NewBoolean(
      value,
    );
  }

  late final _Dart_NewBooleanPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Bool)>>(
          'Dart_NewBoolean');
  late final _Dart_NewBoolean =
      _Dart_NewBooleanPtr.asFunction<Object Function(bool)>();

  /// Gets the value of a Boolean
  ///
  /// \param boolean_obj A Boolean
  /// \param value Returns the value of the Boolean.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_BooleanValue(
    Object boolean_obj,
    ffi.Pointer<ffi.Bool> value,
  ) {
    return _Dart_BooleanValue(
      boolean_obj,
      value,
    );
  }

  late final _Dart_BooleanValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_BooleanValue');
  late final _Dart_BooleanValue = _Dart_BooleanValuePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Gets the length of a String.
  ///
  /// \param str A String.
  /// \param length Returns the length of the String.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringLength(
    Object str,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringLength(
      str,
      length,
    );
  }

  late final _Dart_StringLengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>('Dart_StringLength');
  late final _Dart_StringLength = _Dart_StringLengthPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the length of UTF-8 encoded representation for a string.
  ///
  /// \param str A String.
  /// \param length Returns the length of UTF-8 encoded representation for string.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringUTF8Length(
    Object str,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringUTF8Length(
      str,
      length,
    );
  }

  late final _Dart_StringUTF8LengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>('Dart_StringUTF8Length');
  late final _Dart_StringUTF8Length = _Dart_StringUTF8LengthPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.IntPtr>)>();

  /// Returns a String built from the provided C string
  /// (There is an implicit assumption that the C string passed in contains
  /// UTF-8 encoded characters and '\0' is considered as a termination
  /// character).
  ///
  /// \param str A C String
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromCString(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _Dart_NewStringFromCString(
      str,
    );
  }

  late final _Dart_NewStringFromCStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewStringFromCString');
  late final _Dart_NewStringFromCString = _Dart_NewStringFromCStringPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  /// Returns a String built from an array of UTF-8 encoded characters.
  ///
  /// \param utf8_array An array of UTF-8 encoded characters.
  /// \param length The length of the codepoints array.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromUTF8(
    ffi.Pointer<ffi.Uint8> utf8_array,
    int length,
  ) {
    return _Dart_NewStringFromUTF8(
      utf8_array,
      length,
    );
  }

  late final _Dart_NewStringFromUTF8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>('Dart_NewStringFromUTF8');
  late final _Dart_NewStringFromUTF8 = _Dart_NewStringFromUTF8Ptr.asFunction<
      Object Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Returns a String built from an array of UTF-16 encoded characters.
  ///
  /// \param utf16_array An array of UTF-16 encoded characters.
  /// \param length The length of the codepoints array.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromUTF16(
    ffi.Pointer<ffi.Uint16> utf16_array,
    int length,
  ) {
    return _Dart_NewStringFromUTF16(
      utf16_array,
      length,
    );
  }

  late final _Dart_NewStringFromUTF16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint16>, ffi.IntPtr)>>('Dart_NewStringFromUTF16');
  late final _Dart_NewStringFromUTF16 = _Dart_NewStringFromUTF16Ptr.asFunction<
      Object Function(ffi.Pointer<ffi.Uint16>, int)>();

  /// Returns a String built from an array of UTF-32 encoded characters.
  ///
  /// \param utf32_array An array of UTF-32 encoded characters.
  /// \param length The length of the codepoints array.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromUTF32(
    ffi.Pointer<ffi.Int32> utf32_array,
    int length,
  ) {
    return _Dart_NewStringFromUTF32(
      utf32_array,
      length,
    );
  }

  late final _Dart_NewStringFromUTF32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Int32>, ffi.IntPtr)>>('Dart_NewStringFromUTF32');
  late final _Dart_NewStringFromUTF32 = _Dart_NewStringFromUTF32Ptr.asFunction<
      Object Function(ffi.Pointer<ffi.Int32>, int)>();

  /// Gets the C string representation of a String.
  /// (It is a sequence of UTF-8 encoded values with a '\0' termination.)
  ///
  /// \param str A string.
  /// \param cstr Returns the String represented as a C string.
  /// This C string is scope allocated and is only valid until
  /// the next call to Dart_ExitScope.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToCString(
    Object str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> cstr,
  ) {
    return _Dart_StringToCString(
      str,
      cstr,
    );
  }

  late final _Dart_StringToCStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_StringToCString');
  late final _Dart_StringToCString = _Dart_StringToCStringPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Gets a UTF-8 encoded representation of a String.
  ///
  /// Any unpaired surrogate code points in the string will be converted as
  /// replacement characters (U+FFFD, 0xEF 0xBF 0xBD in UTF-8). If you need
  /// to preserve unpaired surrogates, use the Dart_StringToUTF16 function.
  ///
  /// \param str A string.
  /// \param utf8_array Returns the String represented as UTF-8 code
  /// units.  This UTF-8 array is scope allocated and is only valid
  /// until the next call to Dart_ExitScope.
  /// \param length Used to return the length of the array which was
  /// actually used.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToUTF8(
    Object str,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> utf8_array,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringToUTF8(
      str,
      utf8_array,
      length,
    );
  }

  late final _Dart_StringToUTF8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_StringToUTF8');
  late final _Dart_StringToUTF8 = _Dart_StringToUTF8Ptr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.IntPtr>)>();

  /// Copies the UTF-8 encoded representation of a String into specified buffer.
  ///
  /// Any unpaired surrogate code points in the string will be converted as
  /// replacement characters (U+FFFD, 0xEF 0xBF 0xBD in UTF-8).
  ///
  /// \param str A string.
  /// \param utf8_array Buffer into which the UTF-8 encoded representation of
  /// the string is copied into.
  /// The buffer is allocated and managed by the caller.
  /// \param length Specifies the length of the buffer passed in.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CopyUTF8EncodingOfString(
    Object str,
    ffi.Pointer<ffi.Uint8> utf8_array,
    int length,
  ) {
    return _Dart_CopyUTF8EncodingOfString(
      str,
      utf8_array,
      length,
    );
  }

  late final _Dart_CopyUTF8EncodingOfStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_CopyUTF8EncodingOfString');
  late final _Dart_CopyUTF8EncodingOfString = _Dart_CopyUTF8EncodingOfStringPtr
      .asFunction<Object Function(Object, ffi.Pointer<ffi.Uint8>, int)>();

  /// Gets the data corresponding to the string object. This function returns
  /// the data only for Latin-1 (ISO-8859-1) string objects. For all other
  /// string objects it returns an error.
  ///
  /// \param str A string.
  /// \param latin1_array An array allocated by the caller, used to return
  /// the string data.
  /// \param length Used to pass in the length of the provided array.
  /// Used to return the length of the array which was actually used.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToLatin1(
    Object str,
    ffi.Pointer<ffi.Uint8> latin1_array,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringToLatin1(
      str,
      latin1_array,
      length,
    );
  }

  late final _Dart_StringToLatin1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_StringToLatin1');
  late final _Dart_StringToLatin1 = _Dart_StringToLatin1Ptr.asFunction<
      Object Function(
          Object, ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the UTF-16 encoded representation of a string.
  ///
  /// \param str A string.
  /// \param utf16_array An array allocated by the caller, used to return
  /// the array of UTF-16 encoded characters.
  /// \param length Used to pass in the length of the provided array.
  /// Used to return the length of the array which was actually used.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToUTF16(
    Object str,
    ffi.Pointer<ffi.Uint16> utf16_array,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringToUTF16(
      str,
      utf16_array,
      length,
    );
  }

  late final _Dart_StringToUTF16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Uint16>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_StringToUTF16');
  late final _Dart_StringToUTF16 = _Dart_StringToUTF16Ptr.asFunction<
      Object Function(
          Object, ffi.Pointer<ffi.Uint16>, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the storage size in bytes of a String.
  ///
  /// \param str A String.
  /// \param size Returns the storage size in bytes of the String.
  /// This is the size in bytes needed to store the String.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringStorageSize(
    Object str,
    ffi.Pointer<ffi.IntPtr> size,
  ) {
    return _Dart_StringStorageSize(
      str,
      size,
    );
  }

  late final _Dart_StringStorageSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>('Dart_StringStorageSize');
  late final _Dart_StringStorageSize = _Dart_StringStorageSizePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.IntPtr>)>();

  /// Retrieves some properties associated with a String.
  /// Properties retrieved are:
  /// - character size of the string (one or two byte)
  /// - length of the string
  /// - peer pointer of string if it is an external string.
  /// \param str A String.
  /// \param char_size Returns the character size of the String.
  /// \param str_len Returns the length of the String.
  /// \param peer Returns the peer pointer associated with the String or 0 if
  /// there is no peer pointer for it.
  /// \return Success if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_StringGetProperties(
    Object str,
    ffi.Pointer<ffi.IntPtr> char_size,
    ffi.Pointer<ffi.IntPtr> str_len,
    ffi.Pointer<ffi.Pointer<ffi.Void>> peer,
  ) {
    return _Dart_StringGetProperties(
      str,
      char_size,
      str_len,
      peer,
    );
  }

  late final _Dart_StringGetPropertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('Dart_StringGetProperties');
  late final _Dart_StringGetProperties =
      _Dart_StringGetPropertiesPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.IntPtr>, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Returns a List<dynamic> of the desired length.
  ///
  /// \param length The length of the list.
  ///
  /// \return The List object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewList(
    int length,
  ) {
    return _Dart_NewList(
      length,
    );
  }

  late final _Dart_NewListPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.IntPtr)>>(
          'Dart_NewList');
  late final _Dart_NewList =
      _Dart_NewListPtr.asFunction<Object Function(int)>();

  /// Returns a List of the desired length with the desired element type.
  ///
  /// \param element_type Handle to a nullable type object. E.g., from
  /// Dart_GetType or Dart_GetNullableType.
  ///
  /// \param length The length of the list.
  ///
  /// \return The List object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewListOfType(
    Object element_type,
    int length,
  ) {
    return _Dart_NewListOfType(
      element_type,
      length,
    );
  }

  late final _Dart_NewListOfTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.IntPtr)>>(
          'Dart_NewListOfType');
  late final _Dart_NewListOfType =
      _Dart_NewListOfTypePtr.asFunction<Object Function(Object, int)>();

  /// Returns a List of the desired length with the desired element type, filled
  /// with the provided object.
  ///
  /// \param element_type Handle to a type object. E.g., from Dart_GetType.
  ///
  /// \param fill_object Handle to an object of type 'element_type' that will be
  /// used to populate the list. This parameter can only be Dart_Null() if the
  /// length of the list is 0 or 'element_type' is a nullable type.
  ///
  /// \param length The length of the list.
  ///
  /// \return The List object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewListOfTypeFilled(
    Object element_type,
    Object fill_object,
    int length,
  ) {
    return _Dart_NewListOfTypeFilled(
      element_type,
      fill_object,
      length,
    );
  }

  late final _Dart_NewListOfTypeFilledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Handle, ffi.IntPtr)>>('Dart_NewListOfTypeFilled');
  late final _Dart_NewListOfTypeFilled = _Dart_NewListOfTypeFilledPtr
      .asFunction<Object Function(Object, Object, int)>();

  /// Gets the length of a List.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param list A List.
  /// \param length Returns the length of the List.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_ListLength(
    Object list,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_ListLength(
      list,
      length,
    );
  }

  late final _Dart_ListLengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>('Dart_ListLength');
  late final _Dart_ListLength = _Dart_ListLengthPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the Object at some index of a List.
  ///
  /// If the index is out of bounds, an error occurs.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param list A List.
  /// \param index A valid index into the List.
  ///
  /// \return The Object in the List at the specified index if no error
  /// occurs. Otherwise returns an error handle.
  Object Dart_ListGetAt(
    Object list,
    int index,
  ) {
    return _Dart_ListGetAt(
      list,
      index,
    );
  }

  late final _Dart_ListGetAtPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.IntPtr)>>(
          'Dart_ListGetAt');
  late final _Dart_ListGetAt =
      _Dart_ListGetAtPtr.asFunction<Object Function(Object, int)>();

  /// Gets a range of Objects from a List.
  ///
  /// If any of the requested index values are out of bounds, an error occurs.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param list A List.
  /// \param offset The offset of the first item to get.
  /// \param length The number of items to get.
  /// \param result A pointer to fill with the objects.
  ///
  /// \return Success if no error occurs during the operation.
  Object Dart_ListGetRange(
    Object list,
    int offset,
    int length,
    ffi.Pointer<ffi.Handle> result,
  ) {
    return _Dart_ListGetRange(
      list,
      offset,
      length,
      result,
    );
  }

  late final _Dart_ListGetRangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_ListGetRange');
  late final _Dart_ListGetRange = _Dart_ListGetRangePtr.asFunction<
      Object Function(Object, int, int, ffi.Pointer<ffi.Handle>)>();

  /// Sets the Object at some index of a List.
  ///
  /// If the index is out of bounds, an error occurs.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param list A List.
  /// \param index A valid index into the List.
  /// \param value The Object to put in the List.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_ListSetAt(
    Object list,
    int index,
    Object value,
  ) {
    return _Dart_ListSetAt(
      list,
      index,
      value,
    );
  }

  late final _Dart_ListSetAtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.IntPtr, ffi.Handle)>>('Dart_ListSetAt');
  late final _Dart_ListSetAt =
      _Dart_ListSetAtPtr.asFunction<Object Function(Object, int, Object)>();

  /// May generate an unhandled exception error.
  Object Dart_ListGetAsBytes(
    Object list,
    int offset,
    ffi.Pointer<ffi.Uint8> native_array,
    int length,
  ) {
    return _Dart_ListGetAsBytes(
      list,
      offset,
      native_array,
      length,
    );
  }

  late final _Dart_ListGetAsBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr, ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_ListGetAsBytes');
  late final _Dart_ListGetAsBytes = _Dart_ListGetAsBytesPtr.asFunction<
      Object Function(Object, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// May generate an unhandled exception error.
  Object Dart_ListSetAsBytes(
    Object list,
    int offset,
    ffi.Pointer<ffi.Uint8> native_array,
    int length,
  ) {
    return _Dart_ListSetAsBytes(
      list,
      offset,
      native_array,
      length,
    );
  }

  late final _Dart_ListSetAsBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr, ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_ListSetAsBytes');
  late final _Dart_ListSetAsBytes = _Dart_ListSetAsBytesPtr.asFunction<
      Object Function(Object, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Gets the Object at some key of a Map.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param map A Map.
  /// \param key An Object.
  ///
  /// \return The value in the map at the specified key, null if the map does not
  /// contain the key, or an error handle.
  Object Dart_MapGetAt(
    Object map,
    Object key,
  ) {
    return _Dart_MapGetAt(
      map,
      key,
    );
  }

  late final _Dart_MapGetAtPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_MapGetAt');
  late final _Dart_MapGetAt =
      _Dart_MapGetAtPtr.asFunction<Object Function(Object, Object)>();

  /// Returns whether the Map contains a given key.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param map A Map.
  ///
  /// \return A handle on a boolean indicating whether map contains the key.
  /// Otherwise returns an error handle.
  Object Dart_MapContainsKey(
    Object map,
    Object key,
  ) {
    return _Dart_MapContainsKey(
      map,
      key,
    );
  }

  late final _Dart_MapContainsKeyPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_MapContainsKey');
  late final _Dart_MapContainsKey =
      _Dart_MapContainsKeyPtr.asFunction<Object Function(Object, Object)>();

  /// Gets the list of keys of a Map.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param map A Map.
  ///
  /// \return The list of key Objects if no error occurs. Otherwise returns an
  /// error handle.
  Object Dart_MapKeys(
    Object map,
  ) {
    return _Dart_MapKeys(
      map,
    );
  }

  late final _Dart_MapKeysPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_MapKeys');
  late final _Dart_MapKeys =
      _Dart_MapKeysPtr.asFunction<Object Function(Object)>();

  /// Return type if this object is a TypedData object.
  ///
  /// \return kInvalid if the object is not a TypedData object or the appropriate
  /// Dart_TypedData_Type.
  Dart_TypedData_Type Dart_GetTypeOfTypedData(
    Object object,
  ) {
    return Dart_TypedData_Type.fromValue(_Dart_GetTypeOfTypedData(
      object,
    ));
  }

  late final _Dart_GetTypeOfTypedDataPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Handle)>>(
          'Dart_GetTypeOfTypedData');
  late final _Dart_GetTypeOfTypedData =
      _Dart_GetTypeOfTypedDataPtr.asFunction<int Function(Object)>();

  /// Return type if this object is an external TypedData object.
  ///
  /// \return kInvalid if the object is not an external TypedData object or
  /// the appropriate Dart_TypedData_Type.
  Dart_TypedData_Type Dart_GetTypeOfExternalTypedData(
    Object object,
  ) {
    return Dart_TypedData_Type.fromValue(_Dart_GetTypeOfExternalTypedData(
      object,
    ));
  }

  late final _Dart_GetTypeOfExternalTypedDataPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Handle)>>(
          'Dart_GetTypeOfExternalTypedData');
  late final _Dart_GetTypeOfExternalTypedData =
      _Dart_GetTypeOfExternalTypedDataPtr.asFunction<int Function(Object)>();

  /// Returns a TypedData object of the desired length and type.
  ///
  /// \param type The type of the TypedData object.
  /// \param length The length of the TypedData object (length in type units).
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewTypedData(
    Dart_TypedData_Type type,
    int length,
  ) {
    return _Dart_NewTypedData(
      type.value,
      length,
    );
  }

  late final _Dart_NewTypedDataPtr = _lookup<
          ffi.NativeFunction<ffi.Handle Function(ffi.UnsignedInt, ffi.IntPtr)>>(
      'Dart_NewTypedData');
  late final _Dart_NewTypedData =
      _Dart_NewTypedDataPtr.asFunction<Object Function(int, int)>();

  /// Returns a TypedData object which references an external data array.
  ///
  /// \param type The type of the data array.
  /// \param data A data array. This array must not move.
  /// \param length The length of the data array (length in type units).
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewExternalTypedData(
    Dart_TypedData_Type type,
    ffi.Pointer<ffi.Void> data,
    int length,
  ) {
    return _Dart_NewExternalTypedData(
      type.value,
      data,
      length,
    );
  }

  late final _Dart_NewExternalTypedDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.UnsignedInt, ffi.Pointer<ffi.Void>,
              ffi.IntPtr)>>('Dart_NewExternalTypedData');
  late final _Dart_NewExternalTypedData = _Dart_NewExternalTypedDataPtr
      .asFunction<Object Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Returns a TypedData object which references an external data array.
  ///
  /// \param type The type of the data array.
  /// \param data A data array. This array must not move.
  /// \param length The length of the data array (length in type units).
  /// \param peer A pointer to a native object or NULL.  This value is
  /// provided to callback when it is invoked.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A function pointer that will be invoked sometime
  /// after the object is garbage collected, unless the handle has been deleted.
  /// A valid callback needs to be specified it cannot be NULL.
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewExternalTypedDataWithFinalizer(
    Dart_TypedData_Type type,
    ffi.Pointer<ffi.Void> data,
    int length,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewExternalTypedDataWithFinalizer(
      type.value,
      data,
      length,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewExternalTypedDataWithFinalizerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>>('Dart_NewExternalTypedDataWithFinalizer');
  late final _Dart_NewExternalTypedDataWithFinalizer =
      _Dart_NewExternalTypedDataWithFinalizerPtr.asFunction<
          Object Function(int, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, Dart_HandleFinalizer)>();

  Object Dart_NewUnmodifiableExternalTypedDataWithFinalizer(
    Dart_TypedData_Type type,
    ffi.Pointer<ffi.Void> data,
    int length,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewUnmodifiableExternalTypedDataWithFinalizer(
      type.value,
      data,
      length,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewUnmodifiableExternalTypedDataWithFinalizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.UnsignedInt,
                  ffi.Pointer<ffi.Void>,
                  ffi.IntPtr,
                  ffi.Pointer<ffi.Void>,
                  ffi.IntPtr,
                  Dart_HandleFinalizer)>>(
      'Dart_NewUnmodifiableExternalTypedDataWithFinalizer');
  late final _Dart_NewUnmodifiableExternalTypedDataWithFinalizer =
      _Dart_NewUnmodifiableExternalTypedDataWithFinalizerPtr.asFunction<
          Object Function(int, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, Dart_HandleFinalizer)>();

  /// Returns a ByteBuffer object for the typed data.
  ///
  /// \param typed_data The TypedData object.
  ///
  /// \return The ByteBuffer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewByteBuffer(
    Object typed_data,
  ) {
    return _Dart_NewByteBuffer(
      typed_data,
    );
  }

  late final _Dart_NewByteBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_NewByteBuffer');
  late final _Dart_NewByteBuffer =
      _Dart_NewByteBufferPtr.asFunction<Object Function(Object)>();

  /// Acquires access to the internal data address of a TypedData object.
  ///
  /// \param object The typed data object whose internal data address is to
  /// be accessed.
  /// \param type The type of the object is returned here.
  /// \param data The internal data address is returned here.
  /// \param len Size of the typed array is returned here.
  ///
  /// Notes:
  /// When the internal address of the object is acquired any calls to a
  /// Dart API function that could potentially allocate an object or run
  /// any Dart code will return an error.
  ///
  /// Any Dart API functions for accessing the data should not be called
  /// before the corresponding release. In particular, the object should
  /// not be acquired again before its release. This leads to undefined
  /// behavior.
  ///
  /// \return Success if the internal data address is acquired successfully.
  /// Otherwise, returns an error handle.
  Object Dart_TypedDataAcquireData(
    Object object,
    ffi.Pointer<ffi.UnsignedInt> type,
    ffi.Pointer<ffi.Pointer<ffi.Void>> data,
    ffi.Pointer<ffi.IntPtr> len,
  ) {
    return _Dart_TypedDataAcquireData(
      object,
      type,
      data,
      len,
    );
  }

  late final _Dart_TypedDataAcquireDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_TypedDataAcquireData');
  late final _Dart_TypedDataAcquireData =
      _Dart_TypedDataAcquireDataPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.IntPtr>)>();

  /// Releases access to the internal data address that was acquired earlier using
  /// Dart_TypedDataAcquireData.
  ///
  /// \param object The typed data object whose internal data address is to be
  /// released.
  ///
  /// \return Success if the internal data address is released successfully.
  /// Otherwise, returns an error handle.
  Object Dart_TypedDataReleaseData(
    Object object,
  ) {
    return _Dart_TypedDataReleaseData(
      object,
    );
  }

  late final _Dart_TypedDataReleaseDataPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_TypedDataReleaseData');
  late final _Dart_TypedDataReleaseData =
      _Dart_TypedDataReleaseDataPtr.asFunction<Object Function(Object)>();

  /// Returns the TypedData object associated with the ByteBuffer object.
  ///
  /// \param byte_buffer The ByteBuffer object.
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_GetDataFromByteBuffer(
    Object byte_buffer,
  ) {
    return _Dart_GetDataFromByteBuffer(
      byte_buffer,
    );
  }

  late final _Dart_GetDataFromByteBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_GetDataFromByteBuffer');
  late final _Dart_GetDataFromByteBuffer =
      _Dart_GetDataFromByteBufferPtr.asFunction<Object Function(Object)>();

  /// Invokes a constructor, creating a new object.
  ///
  /// This function allows hidden constructors (constructors with leading
  /// underscores) to be called.
  ///
  /// \param type Type of object to be constructed.
  /// \param constructor_name The name of the constructor to invoke.  Use
  /// Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor.
  /// This name should not include the name of the class.
  /// \param number_of_arguments Size of the arguments array.
  /// \param arguments An array of arguments to the constructor.
  ///
  /// \return If the constructor is called and completes successfully,
  /// then the new object. If an error occurs during execution, then an
  /// error handle is returned.
  Object Dart_New(
    Object type,
    Object constructor_name,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_New(
      type,
      constructor_name,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_NewPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_New');
  late final _Dart_New = _Dart_NewPtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Allocate a new object without invoking a constructor.
  ///
  /// \param type The type of an object to be allocated.
  ///
  /// \return The new object. If an error occurs during execution, then an
  /// error handle is returned.
  Object Dart_Allocate(
    Object type,
  ) {
    return _Dart_Allocate(
      type,
    );
  }

  late final _Dart_AllocatePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_Allocate');
  late final _Dart_Allocate =
      _Dart_AllocatePtr.asFunction<Object Function(Object)>();

  /// Allocate a new object without invoking a constructor, and sets specified
  /// native fields.
  ///
  /// \param type The type of an object to be allocated.
  /// \param num_native_fields The number of native fields to set.
  /// \param native_fields An array containing the value of native fields.
  ///
  /// \return The new object. If an error occurs during execution, then an
  /// error handle is returned.
  Object Dart_AllocateWithNativeFields(
    Object type,
    int num_native_fields,
    ffi.Pointer<ffi.IntPtr> native_fields,
  ) {
    return _Dart_AllocateWithNativeFields(
      type,
      num_native_fields,
      native_fields,
    );
  }

  late final _Dart_AllocateWithNativeFieldsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_AllocateWithNativeFields');
  late final _Dart_AllocateWithNativeFields = _Dart_AllocateWithNativeFieldsPtr
      .asFunction<Object Function(Object, int, ffi.Pointer<ffi.IntPtr>)>();

  /// Invokes a method or function.
  ///
  /// The 'target' parameter may be an object, type, or library.  If
  /// 'target' is an object, then this function will invoke an instance
  /// method.  If 'target' is a type, then this function will invoke a
  /// static method.  If 'target' is a library, then this function will
  /// invoke a top-level function from that library.
  /// NOTE: This API call cannot be used to invoke methods of a type object.
  ///
  /// This function ignores visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param target An object, type, or library.
  /// \param name The name of the function or method to invoke.
  /// \param number_of_arguments Size of the arguments array.
  /// \param arguments An array of arguments to the function.
  ///
  /// \return If the function or method is called and completes
  /// successfully, then the return value is returned. If an error
  /// occurs during execution, then an error handle is returned.
  Object Dart_Invoke(
    Object target,
    Object name,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_Invoke(
      target,
      name,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_InvokePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_Invoke');
  late final _Dart_Invoke = _Dart_InvokePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Invokes a Closure with the given arguments.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \return If no error occurs during execution, then the result of
  /// invoking the closure is returned. If an error occurs during
  /// execution, then an error handle is returned.
  Object Dart_InvokeClosure(
    Object closure,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_InvokeClosure(
      closure,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_InvokeClosurePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_InvokeClosure');
  late final _Dart_InvokeClosure = _Dart_InvokeClosurePtr.asFunction<
      Object Function(Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Invokes a Generative Constructor on an object that was previously
  /// allocated using Dart_Allocate/Dart_AllocateWithNativeFields.
  ///
  /// The 'object' parameter must be an object.
  ///
  /// This function ignores visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param object An object.
  /// \param name The name of the constructor to invoke.
  /// Use Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor.
  /// \param number_of_arguments Size of the arguments array.
  /// \param arguments An array of arguments to the function.
  ///
  /// \return If the constructor is called and completes
  /// successfully, then the object is returned. If an error
  /// occurs during execution, then an error handle is returned.
  Object Dart_InvokeConstructor(
    Object object,
    Object name,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_InvokeConstructor(
      object,
      name,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_InvokeConstructorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_InvokeConstructor');
  late final _Dart_InvokeConstructor = _Dart_InvokeConstructorPtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Gets the value of a field.
  ///
  /// The 'container' parameter may be an object, type, or library.  If
  /// 'container' is an object, then this function will access an
  /// instance field.  If 'container' is a type, then this function will
  /// access a static field.  If 'container' is a library, then this
  /// function will access a top-level variable.
  /// NOTE: This API call cannot be used to access fields of a type object.
  ///
  /// This function ignores field visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param container An object, type, or library.
  /// \param name A field name.
  ///
  /// \return If no error occurs, then the value of the field is
  /// returned. Otherwise an error handle is returned.
  Object Dart_GetField(
    Object container,
    Object name,
  ) {
    return _Dart_GetField(
      container,
      name,
    );
  }

  late final _Dart_GetFieldPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_GetField');
  late final _Dart_GetField =
      _Dart_GetFieldPtr.asFunction<Object Function(Object, Object)>();

  /// Sets the value of a field.
  ///
  /// The 'container' parameter may actually be an object, type, or
  /// library.  If 'container' is an object, then this function will
  /// access an instance field.  If 'container' is a type, then this
  /// function will access a static field.  If 'container' is a library,
  /// then this function will access a top-level variable.
  /// NOTE: This API call cannot be used to access fields of a type object.
  ///
  /// This function ignores field visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param container An object, type, or library.
  /// \param name A field name.
  /// \param value The new field value.
  ///
  /// \return A valid handle if no error occurs.
  Object Dart_SetField(
    Object container,
    Object name,
    Object value,
  ) {
    return _Dart_SetField(
      container,
      name,
      value,
    );
  }

  late final _Dart_SetFieldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Handle, ffi.Handle)>>('Dart_SetField');
  late final _Dart_SetField =
      _Dart_SetFieldPtr.asFunction<Object Function(Object, Object, Object)>();

  /// Throws an exception.
  ///
  /// This function causes a Dart language exception to be thrown. This
  /// will proceed in the standard way, walking up Dart frames until an
  /// appropriate 'catch' block is found, executing 'finally' blocks,
  /// etc.
  ///
  /// If an error handle is passed into this function, the error is
  /// propagated immediately.  See Dart_PropagateError for a discussion
  /// of error propagation.
  ///
  /// If successful, this function does not return. Note that this means
  /// that the destructors of any stack-allocated C++ objects will not be
  /// called. If there are no Dart frames on the stack, an error occurs.
  ///
  /// \return An error handle if the exception was not thrown.
  /// Otherwise the function does not return.
  Object Dart_ThrowException(
    Object exception,
  ) {
    return _Dart_ThrowException(
      exception,
    );
  }

  late final _Dart_ThrowExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ThrowException');
  late final _Dart_ThrowException =
      _Dart_ThrowExceptionPtr.asFunction<Object Function(Object)>();

  /// Rethrows an exception.
  ///
  /// Rethrows an exception, unwinding all dart frames on the stack. If
  /// successful, this function does not return. Note that this means
  /// that the destructors of any stack-allocated C++ objects will not be
  /// called. If there are no Dart frames on the stack, an error occurs.
  ///
  /// \return An error handle if the exception was not thrown.
  /// Otherwise the function does not return.
  Object Dart_ReThrowException(
    Object exception,
    Object stacktrace,
  ) {
    return _Dart_ReThrowException(
      exception,
      stacktrace,
    );
  }

  late final _Dart_ReThrowExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_ReThrowException');
  late final _Dart_ReThrowException =
      _Dart_ReThrowExceptionPtr.asFunction<Object Function(Object, Object)>();

  /// Gets the number of native instance fields in an object.
  Object Dart_GetNativeInstanceFieldCount(
    Object obj,
    ffi.Pointer<ffi.Int> count,
  ) {
    return _Dart_GetNativeInstanceFieldCount(
      obj,
      count,
    );
  }

  late final _Dart_GetNativeInstanceFieldCountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Int>)>>('Dart_GetNativeInstanceFieldCount');
  late final _Dart_GetNativeInstanceFieldCount =
      _Dart_GetNativeInstanceFieldCountPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.Int>)>();

  /// Gets the value of a native field.
  Object Dart_GetNativeInstanceField(
    Object obj,
    int index,
    ffi.Pointer<ffi.IntPtr> value,
  ) {
    return _Dart_GetNativeInstanceField(
      obj,
      index,
      value,
    );
  }

  late final _Dart_GetNativeInstanceFieldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetNativeInstanceField');
  late final _Dart_GetNativeInstanceField = _Dart_GetNativeInstanceFieldPtr
      .asFunction<Object Function(Object, int, ffi.Pointer<ffi.IntPtr>)>();

  /// Sets the value of a native field.
  Object Dart_SetNativeInstanceField(
    Object obj,
    int index,
    int value,
  ) {
    return _Dart_SetNativeInstanceField(
      obj,
      index,
      value,
    );
  }

  late final _Dart_SetNativeInstanceFieldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Int, ffi.IntPtr)>>('Dart_SetNativeInstanceField');
  late final _Dart_SetNativeInstanceField = _Dart_SetNativeInstanceFieldPtr
      .asFunction<Object Function(Object, int, int)>();

  /// Extracts current isolate group data from the native arguments structure.
  ffi.Pointer<ffi.Void> Dart_GetNativeIsolateGroupData(
    Dart_NativeArguments args,
  ) {
    return _Dart_GetNativeIsolateGroupData(
      args,
    );
  }

  late final _Dart_GetNativeIsolateGroupDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              Dart_NativeArguments)>>('Dart_GetNativeIsolateGroupData');
  late final _Dart_GetNativeIsolateGroupData =
      _Dart_GetNativeIsolateGroupDataPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(Dart_NativeArguments)>();

  /// Gets the native arguments based on the types passed in and populates
  /// the passed arguments buffer with appropriate native values.
  ///
  /// \param args the Native arguments block passed into the native call.
  /// \param num_arguments length of argument descriptor array and argument
  /// values array passed in.
  /// \param arg_descriptors an array that describes the arguments that
  /// need to be retrieved. For each argument to be retrieved the descriptor
  /// contains the argument number (0, 1 etc.) and the argument type
  /// described using Dart_NativeArgument_Type, e.g:
  /// DART_NATIVE_ARG_DESCRIPTOR(Dart_NativeArgument_kBool, 1) indicates
  /// that the first argument is to be retrieved and it should be a boolean.
  /// \param arg_values array into which the native arguments need to be
  /// extracted into, the array is allocated by the caller (it could be
  /// stack allocated to avoid the malloc/free performance overhead).
  ///
  /// \return Success if all the arguments could be extracted correctly,
  /// returns an error handle if there were any errors while extracting the
  /// arguments (mismatched number of arguments, incorrect types, etc.).
  Object Dart_GetNativeArguments(
    Dart_NativeArguments args,
    int num_arguments,
    ffi.Pointer<Dart_NativeArgument_Descriptor> arg_descriptors,
    ffi.Pointer<Dart_NativeArgument_Value> arg_values,
  ) {
    return _Dart_GetNativeArguments(
      args,
      num_arguments,
      arg_descriptors,
      arg_values,
    );
  }

  late final _Dart_GetNativeArgumentsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_NativeArguments,
                  ffi.Int,
                  ffi.Pointer<Dart_NativeArgument_Descriptor>,
                  ffi.Pointer<Dart_NativeArgument_Value>)>>(
      'Dart_GetNativeArguments');
  late final _Dart_GetNativeArguments = _Dart_GetNativeArgumentsPtr.asFunction<
      Object Function(
          Dart_NativeArguments,
          int,
          ffi.Pointer<Dart_NativeArgument_Descriptor>,
          ffi.Pointer<Dart_NativeArgument_Value>)>();

  /// Gets the native argument at some index.
  Object Dart_GetNativeArgument(
    Dart_NativeArguments args,
    int index,
  ) {
    return _Dart_GetNativeArgument(
      args,
      index,
    );
  }

  late final _Dart_GetNativeArgumentPtr = _lookup<
          ffi
          .NativeFunction<ffi.Handle Function(Dart_NativeArguments, ffi.Int)>>(
      'Dart_GetNativeArgument');
  late final _Dart_GetNativeArgument = _Dart_GetNativeArgumentPtr.asFunction<
      Object Function(Dart_NativeArguments, int)>();

  /// Gets the number of native arguments.
  int Dart_GetNativeArgumentCount(
    Dart_NativeArguments args,
  ) {
    return _Dart_GetNativeArgumentCount(
      args,
    );
  }

  late final _Dart_GetNativeArgumentCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Dart_NativeArguments)>>(
          'Dart_GetNativeArgumentCount');
  late final _Dart_GetNativeArgumentCount = _Dart_GetNativeArgumentCountPtr
      .asFunction<int Function(Dart_NativeArguments)>();

  /// Gets all the native fields of the native argument at some index.
  /// \param args Native arguments structure.
  /// \param arg_index Index of the desired argument in the structure above.
  /// \param num_fields size of the intptr_t array 'field_values' passed in.
  /// \param field_values intptr_t array in which native field values are returned.
  /// \return Success if the native fields where copied in successfully. Otherwise
  /// returns an error handle. On success the native field values are copied
  /// into the 'field_values' array, if the argument at 'arg_index' is a
  /// null object then 0 is copied as the native field values into the
  /// 'field_values' array.
  Object Dart_GetNativeFieldsOfArgument(
    Dart_NativeArguments args,
    int arg_index,
    int num_fields,
    ffi.Pointer<ffi.IntPtr> field_values,
  ) {
    return _Dart_GetNativeFieldsOfArgument(
      args,
      arg_index,
      num_fields,
      field_values,
    );
  }

  late final _Dart_GetNativeFieldsOfArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetNativeFieldsOfArgument');
  late final _Dart_GetNativeFieldsOfArgument =
      _Dart_GetNativeFieldsOfArgumentPtr.asFunction<
          Object Function(
              Dart_NativeArguments, int, int, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the native field of the receiver.
  Object Dart_GetNativeReceiver(
    Dart_NativeArguments args,
    ffi.Pointer<ffi.IntPtr> value,
  ) {
    return _Dart_GetNativeReceiver(
      args,
      value,
    );
  }

  late final _Dart_GetNativeReceiverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetNativeReceiver');
  late final _Dart_GetNativeReceiver = _Dart_GetNativeReceiverPtr.asFunction<
      Object Function(Dart_NativeArguments, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets a string native argument at some index.
  /// \param args Native arguments structure.
  /// \param arg_index Index of the desired argument in the structure above.
  /// \param peer Returns the peer pointer if the string argument has one.
  /// \return Success if the string argument has a peer, if it does not
  /// have a peer then the String object is returned. Otherwise returns
  /// an error handle (argument is not a String object).
  Object Dart_GetNativeStringArgument(
    Dart_NativeArguments args,
    int arg_index,
    ffi.Pointer<ffi.Pointer<ffi.Void>> peer,
  ) {
    return _Dart_GetNativeStringArgument(
      args,
      arg_index,
      peer,
    );
  }

  late final _Dart_GetNativeStringArgumentPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(Dart_NativeArguments, ffi.Int,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>)>>(
      'Dart_GetNativeStringArgument');
  late final _Dart_GetNativeStringArgument =
      _Dart_GetNativeStringArgumentPtr.asFunction<
          Object Function(
              Dart_NativeArguments, int, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Gets an integer native argument at some index.
  /// \param args Native arguments structure.
  /// \param index Index of the desired argument in the structure above.
  /// \param value Returns the integer value if the argument is an Integer.
  /// \return Success if no error occurs. Otherwise returns an error handle.
  Object Dart_GetNativeIntegerArgument(
    Dart_NativeArguments args,
    int index,
    ffi.Pointer<ffi.Int64> value,
  ) {
    return _Dart_GetNativeIntegerArgument(
      args,
      index,
      value,
    );
  }

  late final _Dart_GetNativeIntegerArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int,
              ffi.Pointer<ffi.Int64>)>>('Dart_GetNativeIntegerArgument');
  late final _Dart_GetNativeIntegerArgument =
      _Dart_GetNativeIntegerArgumentPtr.asFunction<
          Object Function(Dart_NativeArguments, int, ffi.Pointer<ffi.Int64>)>();

  /// Gets a boolean native argument at some index.
  /// \param args Native arguments structure.
  /// \param index Index of the desired argument in the structure above.
  /// \param value Returns the boolean value if the argument is a Boolean.
  /// \return Success if no error occurs. Otherwise returns an error handle.
  Object Dart_GetNativeBooleanArgument(
    Dart_NativeArguments args,
    int index,
    ffi.Pointer<ffi.Bool> value,
  ) {
    return _Dart_GetNativeBooleanArgument(
      args,
      index,
      value,
    );
  }

  late final _Dart_GetNativeBooleanArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int,
              ffi.Pointer<ffi.Bool>)>>('Dart_GetNativeBooleanArgument');
  late final _Dart_GetNativeBooleanArgument =
      _Dart_GetNativeBooleanArgumentPtr.asFunction<
          Object Function(Dart_NativeArguments, int, ffi.Pointer<ffi.Bool>)>();

  /// Gets a double native argument at some index.
  /// \param args Native arguments structure.
  /// \param index Index of the desired argument in the structure above.
  /// \param value Returns the double value if the argument is a double.
  /// \return Success if no error occurs. Otherwise returns an error handle.
  Object Dart_GetNativeDoubleArgument(
    Dart_NativeArguments args,
    int index,
    ffi.Pointer<ffi.Double> value,
  ) {
    return _Dart_GetNativeDoubleArgument(
      args,
      index,
      value,
    );
  }

  late final _Dart_GetNativeDoubleArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int,
              ffi.Pointer<ffi.Double>)>>('Dart_GetNativeDoubleArgument');
  late final _Dart_GetNativeDoubleArgument =
      _Dart_GetNativeDoubleArgumentPtr.asFunction<
          Object Function(
              Dart_NativeArguments, int, ffi.Pointer<ffi.Double>)>();

  /// Sets the return value for a native function.
  ///
  /// If retval is an Error handle, then error will be propagated once
  /// the native functions exits. See Dart_PropagateError for a
  /// discussion of how different types of errors are propagated.
  void Dart_SetReturnValue(
    Dart_NativeArguments args,
    Object retval,
  ) {
    return _Dart_SetReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetReturnValuePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Dart_NativeArguments, ffi.Handle)>>(
      'Dart_SetReturnValue');
  late final _Dart_SetReturnValue = _Dart_SetReturnValuePtr.asFunction<
      void Function(Dart_NativeArguments, Object)>();

  void Dart_SetWeakHandleReturnValue(
    Dart_NativeArguments args,
    Dart_WeakPersistentHandle rval,
  ) {
    return _Dart_SetWeakHandleReturnValue(
      args,
      rval,
    );
  }

  late final _Dart_SetWeakHandleReturnValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Dart_NativeArguments,
              Dart_WeakPersistentHandle)>>('Dart_SetWeakHandleReturnValue');
  late final _Dart_SetWeakHandleReturnValue =
      _Dart_SetWeakHandleReturnValuePtr.asFunction<
          void Function(Dart_NativeArguments, Dart_WeakPersistentHandle)>();

  void Dart_SetBooleanReturnValue(
    Dart_NativeArguments args,
    bool retval,
  ) {
    return _Dart_SetBooleanReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetBooleanReturnValuePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Dart_NativeArguments, ffi.Bool)>>(
      'Dart_SetBooleanReturnValue');
  late final _Dart_SetBooleanReturnValue = _Dart_SetBooleanReturnValuePtr
      .asFunction<void Function(Dart_NativeArguments, bool)>();

  void Dart_SetIntegerReturnValue(
    Dart_NativeArguments args,
    int retval,
  ) {
    return _Dart_SetIntegerReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetIntegerReturnValuePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Dart_NativeArguments, ffi.Int64)>>(
      'Dart_SetIntegerReturnValue');
  late final _Dart_SetIntegerReturnValue = _Dart_SetIntegerReturnValuePtr
      .asFunction<void Function(Dart_NativeArguments, int)>();

  void Dart_SetDoubleReturnValue(
    Dart_NativeArguments args,
    double retval,
  ) {
    return _Dart_SetDoubleReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetDoubleReturnValuePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Dart_NativeArguments, ffi.Double)>>(
      'Dart_SetDoubleReturnValue');
  late final _Dart_SetDoubleReturnValue = _Dart_SetDoubleReturnValuePtr
      .asFunction<void Function(Dart_NativeArguments, double)>();

  /// Sets the environment callback for the current isolate. This
  /// callback is used to lookup environment values by name in the
  /// current environment. This enables the embedder to supply values for
  /// the const constructors bool.fromEnvironment, int.fromEnvironment
  /// and String.fromEnvironment.
  Object Dart_SetEnvironmentCallback(
    Dart_EnvironmentCallback callback,
  ) {
    return _Dart_SetEnvironmentCallback(
      callback,
    );
  }

  late final _Dart_SetEnvironmentCallbackPtr = _lookup<
          ffi.NativeFunction<ffi.Handle Function(Dart_EnvironmentCallback)>>(
      'Dart_SetEnvironmentCallback');
  late final _Dart_SetEnvironmentCallback = _Dart_SetEnvironmentCallbackPtr
      .asFunction<Object Function(Dart_EnvironmentCallback)>();

  /// Sets the callback used to resolve native functions for a library.
  ///
  /// \param library A library.
  /// \param resolver A native entry resolver.
  ///
  /// \return A valid handle if the native resolver was set successfully.
  Object Dart_SetNativeResolver(
    Object library$,
    Dart_NativeEntryResolver resolver,
    Dart_NativeEntrySymbol symbol,
  ) {
    return _Dart_SetNativeResolver(
      library$,
      resolver,
      symbol,
    );
  }

  late final _Dart_SetNativeResolverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, Dart_NativeEntryResolver,
              Dart_NativeEntrySymbol)>>('Dart_SetNativeResolver');
  late final _Dart_SetNativeResolver = _Dart_SetNativeResolverPtr.asFunction<
      Object Function(
          Object, Dart_NativeEntryResolver, Dart_NativeEntrySymbol)>();

  /// Returns the callback used to resolve native functions for a library.
  ///
  /// \param library A library.
  /// \param resolver a pointer to a Dart_NativeEntryResolver
  ///
  /// \return A valid handle if the library was found.
  Object Dart_GetNativeResolver(
    Object library$,
    ffi.Pointer<Dart_NativeEntryResolver> resolver,
  ) {
    return _Dart_GetNativeResolver(
      library$,
      resolver,
    );
  }

  late final _Dart_GetNativeResolverPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Pointer<Dart_NativeEntryResolver>)>>(
      'Dart_GetNativeResolver');
  late final _Dart_GetNativeResolver = _Dart_GetNativeResolverPtr.asFunction<
      Object Function(Object, ffi.Pointer<Dart_NativeEntryResolver>)>();

  /// Returns the callback used to resolve native function symbols for a library.
  ///
  /// \param library A library.
  /// \param resolver a pointer to a Dart_NativeEntrySymbol.
  ///
  /// \return A valid handle if the library was found.
  Object Dart_GetNativeSymbol(
    Object library$,
    ffi.Pointer<Dart_NativeEntrySymbol> resolver,
  ) {
    return _Dart_GetNativeSymbol(
      library$,
      resolver,
    );
  }

  late final _Dart_GetNativeSymbolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<Dart_NativeEntrySymbol>)>>('Dart_GetNativeSymbol');
  late final _Dart_GetNativeSymbol = _Dart_GetNativeSymbolPtr.asFunction<
      Object Function(Object, ffi.Pointer<Dart_NativeEntrySymbol>)>();

  /// Sets the callback used to resolve FFI native functions for a library.
  /// The resolved functions are expected to be a C function pointer of the
  /// correct signature (as specified in the `@Native<NFT>()` function
  /// annotation in Dart code).
  ///
  /// NOTE: This is an experimental feature and might change in the future.
  ///
  /// \param library A library.
  /// \param resolver A native function resolver.
  ///
  /// \return A valid handle if the native resolver was set successfully.
  Object Dart_SetFfiNativeResolver(
    Object library$,
    Dart_FfiNativeResolver resolver,
  ) {
    return _Dart_SetFfiNativeResolver(
      library$,
      resolver,
    );
  }

  late final _Dart_SetFfiNativeResolverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              Dart_FfiNativeResolver)>>('Dart_SetFfiNativeResolver');
  late final _Dart_SetFfiNativeResolver = _Dart_SetFfiNativeResolverPtr
      .asFunction<Object Function(Object, Dart_FfiNativeResolver)>();

  /// Initializes native asset resolution for the current isolate group.
  ///
  /// The caller is responsible for ensuring this is called right after isolate
  /// group creation, and before running any dart code (or spawning isolates).
  ///
  /// @param native_assets_api The callbacks used by native assets resolution.
  /// The VM does not take ownership of the parameter,
  /// it can be freed immediately after the call.
  void Dart_InitializeNativeAssetsResolver(
    ffi.Pointer<NativeAssetsApi> native_assets_api,
  ) {
    return _Dart_InitializeNativeAssetsResolver(
      native_assets_api,
    );
  }

  late final _Dart_InitializeNativeAssetsResolverPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NativeAssetsApi>)>>(
      'Dart_InitializeNativeAssetsResolver');
  late final _Dart_InitializeNativeAssetsResolver =
      _Dart_InitializeNativeAssetsResolverPtr.asFunction<
          void Function(ffi.Pointer<NativeAssetsApi>)>();

  /// Sets library tag handler for the current isolate. This handler is
  /// used to handle the various tags encountered while loading libraries
  /// or scripts in the isolate.
  ///
  /// \param handler Handler code to be used for handling the various tags
  /// encountered while loading libraries or scripts in the isolate.
  ///
  /// \return If no error occurs, the handler is set for the isolate.
  /// Otherwise an error handle is returned.
  Object Dart_SetLibraryTagHandler(
    Dart_LibraryTagHandler handler,
  ) {
    return _Dart_SetLibraryTagHandler(
      handler,
    );
  }

  late final _Dart_SetLibraryTagHandlerPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(Dart_LibraryTagHandler)>>(
          'Dart_SetLibraryTagHandler');
  late final _Dart_SetLibraryTagHandler = _Dart_SetLibraryTagHandlerPtr
      .asFunction<Object Function(Dart_LibraryTagHandler)>();

  /// Sets the deferred load handler for the current isolate. This handler is
  /// used to handle loading deferred imports in an AppJIT or AppAOT program.
  Object Dart_SetDeferredLoadHandler(
    Dart_DeferredLoadHandler handler,
  ) {
    return _Dart_SetDeferredLoadHandler(
      handler,
    );
  }

  late final _Dart_SetDeferredLoadHandlerPtr = _lookup<
          ffi.NativeFunction<ffi.Handle Function(Dart_DeferredLoadHandler)>>(
      'Dart_SetDeferredLoadHandler');
  late final _Dart_SetDeferredLoadHandler = _Dart_SetDeferredLoadHandlerPtr
      .asFunction<Object Function(Dart_DeferredLoadHandler)>();

  /// Notifies the VM that a deferred load completed successfully. This function
  /// will eventually cause the corresponding `prefix.loadLibrary()` futures to
  /// complete.
  ///
  /// Requires the current isolate to be the same current isolate during the
  /// invocation of the Dart_DeferredLoadHandler.
  Object Dart_DeferredLoadComplete(
    int loading_unit_id,
    ffi.Pointer<ffi.Uint8> snapshot_data,
    ffi.Pointer<ffi.Uint8> snapshot_instructions,
  ) {
    return _Dart_DeferredLoadComplete(
      loading_unit_id,
      snapshot_data,
      snapshot_instructions,
    );
  }

  late final _Dart_DeferredLoadCompletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.IntPtr, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>)>>('Dart_DeferredLoadComplete');
  late final _Dart_DeferredLoadComplete =
      _Dart_DeferredLoadCompletePtr.asFunction<
          Object Function(
              int, ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint8>)>();

  /// Notifies the VM that a deferred load failed. This function
  /// will eventually cause the corresponding `prefix.loadLibrary()` futures to
  /// complete with an error.
  ///
  /// If `transient` is true, future invocations of `prefix.loadLibrary()` will
  /// trigger new load requests. If false, futures invocation will complete with
  /// the same error.
  ///
  /// Requires the current isolate to be the same current isolate during the
  /// invocation of the Dart_DeferredLoadHandler.
  Object Dart_DeferredLoadCompleteError(
    int loading_unit_id,
    ffi.Pointer<ffi.Char> error_message,
    bool transient,
  ) {
    return _Dart_DeferredLoadCompleteError(
      loading_unit_id,
      error_message,
      transient,
    );
  }

  late final _Dart_DeferredLoadCompleteErrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.IntPtr, ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('Dart_DeferredLoadCompleteError');
  late final _Dart_DeferredLoadCompleteError =
      _Dart_DeferredLoadCompleteErrorPtr.asFunction<
          Object Function(int, ffi.Pointer<ffi.Char>, bool)>();

  /// Loads the root library for the current isolate.
  ///
  /// Requires there to be no current root library.
  ///
  /// \param kernel_buffer A buffer which contains a kernel binary (see
  /// pkg/kernel/binary.md). Must remain valid until isolate group shutdown.
  /// \param kernel_size Length of the passed in buffer.
  ///
  /// \return A handle to the root library, or an error.
  Object Dart_LoadScriptFromKernel(
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_size,
  ) {
    return _Dart_LoadScriptFromKernel(
      kernel_buffer,
      kernel_size,
    );
  }

  late final _Dart_LoadScriptFromKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_LoadScriptFromKernel');
  late final _Dart_LoadScriptFromKernel = _Dart_LoadScriptFromKernelPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Gets the library for the root script for the current isolate.
  ///
  /// If the root script has not yet been set for the current isolate,
  /// this function returns Dart_Null().  This function never returns an
  /// error handle.
  ///
  /// \return Returns the root Library for the current isolate or Dart_Null().
  Object Dart_RootLibrary() {
    return _Dart_RootLibrary();
  }

  late final _Dart_RootLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_RootLibrary');
  late final _Dart_RootLibrary =
      _Dart_RootLibraryPtr.asFunction<Object Function()>();

  /// Sets the root library for the current isolate.
  ///
  /// \return Returns an error handle if `library` is not a library handle.
  Object Dart_SetRootLibrary(
    Object library$,
  ) {
    return _Dart_SetRootLibrary(
      library$,
    );
  }

  late final _Dart_SetRootLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_SetRootLibrary');
  late final _Dart_SetRootLibrary =
      _Dart_SetRootLibraryPtr.asFunction<Object Function(Object)>();

  /// Lookup or instantiate a legacy type by name and type arguments from a
  /// Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The class name for the type.
  /// \param number_of_type_arguments Number of type arguments.
  /// For non parametric types the number of type arguments would be 0.
  /// \param type_arguments Pointer to an array of type arguments.
  /// For non parametric types a NULL would be passed in for this argument.
  ///
  /// \return If no error occurs, the type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_GetType(
    Object library$,
    Object class_name,
    int number_of_type_arguments,
    ffi.Pointer<ffi.Handle> type_arguments,
  ) {
    return _Dart_GetType(
      library$,
      class_name,
      number_of_type_arguments,
      type_arguments,
    );
  }

  late final _Dart_GetTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_GetType');
  late final _Dart_GetType = _Dart_GetTypePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Lookup or instantiate a nullable type by name and type arguments from
  /// Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The class name for the type.
  /// \param number_of_type_arguments Number of type arguments.
  /// For non parametric types the number of type arguments would be 0.
  /// \param type_arguments Pointer to an array of type arguments.
  /// For non parametric types a NULL would be passed in for this argument.
  ///
  /// \return If no error occurs, the type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_GetNullableType(
    Object library$,
    Object class_name,
    int number_of_type_arguments,
    ffi.Pointer<ffi.Handle> type_arguments,
  ) {
    return _Dart_GetNullableType(
      library$,
      class_name,
      number_of_type_arguments,
      type_arguments,
    );
  }

  late final _Dart_GetNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_GetNullableType');
  late final _Dart_GetNullableType = _Dart_GetNullableTypePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Lookup or instantiate a non-nullable type by name and type arguments from
  /// Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The class name for the type.
  /// \param number_of_type_arguments Number of type arguments.
  /// For non parametric types the number of type arguments would be 0.
  /// \param type_arguments Pointer to an array of type arguments.
  /// For non parametric types a NULL would be passed in for this argument.
  ///
  /// \return If no error occurs, the type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_GetNonNullableType(
    Object library$,
    Object class_name,
    int number_of_type_arguments,
    ffi.Pointer<ffi.Handle> type_arguments,
  ) {
    return _Dart_GetNonNullableType(
      library$,
      class_name,
      number_of_type_arguments,
      type_arguments,
    );
  }

  late final _Dart_GetNonNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_GetNonNullableType');
  late final _Dart_GetNonNullableType = _Dart_GetNonNullableTypePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Creates a nullable version of the provided type.
  ///
  /// \param type The type to be converted to a nullable type.
  ///
  /// \return If no error occurs, a nullable type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_TypeToNullableType(
    Object type,
  ) {
    return _Dart_TypeToNullableType(
      type,
    );
  }

  late final _Dart_TypeToNullableTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_TypeToNullableType');
  late final _Dart_TypeToNullableType =
      _Dart_TypeToNullableTypePtr.asFunction<Object Function(Object)>();

  /// Creates a non-nullable version of the provided type.
  ///
  /// \param type The type to be converted to a non-nullable type.
  ///
  /// \return If no error occurs, a non-nullable type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_TypeToNonNullableType(
    Object type,
  ) {
    return _Dart_TypeToNonNullableType(
      type,
    );
  }

  late final _Dart_TypeToNonNullableTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_TypeToNonNullableType');
  late final _Dart_TypeToNonNullableType =
      _Dart_TypeToNonNullableTypePtr.asFunction<Object Function(Object)>();

  /// A type's nullability.
  ///
  /// \param type A Dart type.
  /// \param result An out parameter containing the result of the check. True if
  /// the type is of the specified nullability, false otherwise.
  ///
  /// \return Returns an error handle if type is not of type Type.
  Object Dart_IsNullableType(
    Object type,
    ffi.Pointer<ffi.Bool> result,
  ) {
    return _Dart_IsNullableType(
      type,
      result,
    );
  }

  late final _Dart_IsNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_IsNullableType');
  late final _Dart_IsNullableType = _Dart_IsNullableTypePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  Object Dart_IsNonNullableType(
    Object type,
    ffi.Pointer<ffi.Bool> result,
  ) {
    return _Dart_IsNonNullableType(
      type,
      result,
    );
  }

  late final _Dart_IsNonNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_IsNonNullableType');
  late final _Dart_IsNonNullableType = _Dart_IsNonNullableTypePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Lookup a class or interface by name from a Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The name of the class or interface.
  ///
  /// \return If no error occurs, the class or interface is
  /// returned. Otherwise an error handle is returned.
  Object Dart_GetClass(
    Object library$,
    Object class_name,
  ) {
    return _Dart_GetClass(
      library$,
      class_name,
    );
  }

  late final _Dart_GetClassPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_GetClass');
  late final _Dart_GetClass =
      _Dart_GetClassPtr.asFunction<Object Function(Object, Object)>();

  /// Returns an import path to a Library, such as "file:///test.dart" or
  /// "dart:core".
  Object Dart_LibraryUrl(
    Object library$,
  ) {
    return _Dart_LibraryUrl(
      library$,
    );
  }

  late final _Dart_LibraryUrlPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_LibraryUrl');
  late final _Dart_LibraryUrl =
      _Dart_LibraryUrlPtr.asFunction<Object Function(Object)>();

  /// Returns a URL from which a Library was loaded.
  Object Dart_LibraryResolvedUrl(
    Object library$,
  ) {
    return _Dart_LibraryResolvedUrl(
      library$,
    );
  }

  late final _Dart_LibraryResolvedUrlPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_LibraryResolvedUrl');
  late final _Dart_LibraryResolvedUrl =
      _Dart_LibraryResolvedUrlPtr.asFunction<Object Function(Object)>();

  /// \return An array of libraries.
  Object Dart_GetLoadedLibraries() {
    return _Dart_GetLoadedLibraries();
  }

  late final _Dart_GetLoadedLibrariesPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>(
          'Dart_GetLoadedLibraries');
  late final _Dart_GetLoadedLibraries =
      _Dart_GetLoadedLibrariesPtr.asFunction<Object Function()>();

  Object Dart_LookupLibrary(
    Object url,
  ) {
    return _Dart_LookupLibrary(
      url,
    );
  }

  late final _Dart_LookupLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_LookupLibrary');
  late final _Dart_LookupLibrary =
      _Dart_LookupLibraryPtr.asFunction<Object Function(Object)>();

  /// Report an loading error for the library.
  ///
  /// \param library The library that failed to load.
  /// \param error The Dart error instance containing the load error.
  ///
  /// \return If the VM handles the error, the return value is
  /// a null handle. If it doesn't handle the error, the error
  /// object is returned.
  Object Dart_LibraryHandleError(
    Object library$,
    Object error,
  ) {
    return _Dart_LibraryHandleError(
      library$,
      error,
    );
  }

  late final _Dart_LibraryHandleErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_LibraryHandleError');
  late final _Dart_LibraryHandleError =
      _Dart_LibraryHandleErrorPtr.asFunction<Object Function(Object, Object)>();

  /// Called by the embedder to load a partial program. Does not set the root
  /// library.
  ///
  /// \param kernel_buffer A buffer which contains a kernel binary (see
  /// pkg/kernel/binary.md). Must remain valid until isolate shutdown.
  /// \param kernel_buffer_size Length of the passed in buffer.
  ///
  /// \return A handle to the main library of the compilation unit, or an error.
  Object Dart_LoadLibraryFromKernel(
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_buffer_size,
  ) {
    return _Dart_LoadLibraryFromKernel(
      kernel_buffer,
      kernel_buffer_size,
    );
  }

  late final _Dart_LoadLibraryFromKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_LoadLibraryFromKernel');
  late final _Dart_LoadLibraryFromKernel = _Dart_LoadLibraryFromKernelPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Uint8>, int)>();

  Object Dart_LoadLibrary(
    Object kernel_buffer,
  ) {
    return _Dart_LoadLibrary(
      kernel_buffer,
    );
  }

  late final _Dart_LoadLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_LoadLibrary');
  late final _Dart_LoadLibrary =
      _Dart_LoadLibraryPtr.asFunction<Object Function(Object)>();

  /// Indicates that all outstanding load requests have been satisfied.
  /// This finalizes all the new classes loaded and optionally completes
  /// deferred library futures.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param complete_futures Specify true if all deferred library
  /// futures should be completed, false otherwise.
  ///
  /// \return Success if all classes have been finalized and deferred library
  /// futures are completed. Otherwise, returns an error.
  Object Dart_FinalizeLoading(
    bool complete_futures,
  ) {
    return _Dart_FinalizeLoading(
      complete_futures,
    );
  }

  late final _Dart_FinalizeLoadingPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Bool)>>(
          'Dart_FinalizeLoading');
  late final _Dart_FinalizeLoading =
      _Dart_FinalizeLoadingPtr.asFunction<Object Function(bool)>();

  /// Returns the value of peer field of 'object' in 'peer'.
  ///
  /// \param object An object.
  /// \param peer An out parameter that returns the value of the peer
  /// field.
  ///
  /// \return Returns an error if 'object' is a subtype of Null, num, or
  /// bool.
  Object Dart_GetPeer(
    Object object,
    ffi.Pointer<ffi.Pointer<ffi.Void>> peer,
  ) {
    return _Dart_GetPeer(
      object,
      peer,
    );
  }

  late final _Dart_GetPeerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('Dart_GetPeer');
  late final _Dart_GetPeer = _Dart_GetPeerPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Sets the value of the peer field of 'object' to the value of
  /// 'peer'.
  ///
  /// \param object An object.
  /// \param peer A value to store in the peer field.
  ///
  /// \return Returns an error if 'object' is a subtype of Null, num, or
  /// bool.
  Object Dart_SetPeer(
    Object object,
    ffi.Pointer<ffi.Void> peer,
  ) {
    return _Dart_SetPeer(
      object,
      peer,
    );
  }

  late final _Dart_SetPeerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Void>)>>('Dart_SetPeer');
  late final _Dart_SetPeer = _Dart_SetPeerPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Void>)>();

  bool Dart_IsKernelIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsKernelIsolate(
      isolate,
    );
  }

  late final _Dart_IsKernelIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Isolate)>>(
          'Dart_IsKernelIsolate');
  late final _Dart_IsKernelIsolate =
      _Dart_IsKernelIsolatePtr.asFunction<bool Function(Dart_Isolate)>();

  bool Dart_KernelIsolateIsRunning() {
    return _Dart_KernelIsolateIsRunning();
  }

  late final _Dart_KernelIsolateIsRunningPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_KernelIsolateIsRunning');
  late final _Dart_KernelIsolateIsRunning =
      _Dart_KernelIsolateIsRunningPtr.asFunction<bool Function()>();

  int Dart_KernelPort() {
    return _Dart_KernelPort();
  }

  late final _Dart_KernelPortPtr =
      _lookup<ffi.NativeFunction<Dart_Port Function()>>('Dart_KernelPort');
  late final _Dart_KernelPort =
      _Dart_KernelPortPtr.asFunction<int Function()>();

  /// Compiles the given `script_uri` to a kernel file.
  ///
  /// \param platform_kernel A buffer containing the kernel of the platform (e.g.
  /// `vm_platform_strong.dill`). The VM does not take ownership of this memory.
  ///
  /// \param platform_kernel_size The length of the platform_kernel buffer.
  ///
  /// \param snapshot_compile Set to `true` when the compilation is for a snapshot.
  /// This is used by the frontend to determine if compilation related information
  /// should be printed to console (e.g., null safety mode).
  ///
  /// \param embed_sources Set to `true` when sources should be embedded in the
  /// kernel file.
  ///
  /// \param verbosity Specifies the logging behavior of the kernel compilation
  /// service.
  ///
  /// \return Returns the result of the compilation.
  ///
  /// On a successful compilation the returned [Dart_KernelCompilationResult] has
  /// a status of [Dart_KernelCompilationStatus_Ok] and the `kernel`/`kernel_size`
  /// fields are set. The caller takes ownership of the malloc()ed buffer.
  ///
  /// On a failed compilation the `error` might be set describing the reason for
  /// the failed compilation. The caller takes ownership of the malloc()ed
  /// error.
  ///
  /// Requires there to be a current isolate.
  Dart_KernelCompilationResult Dart_CompileToKernel(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Uint8> platform_kernel,
    int platform_kernel_size,
    bool incremental_compile,
    bool snapshot_compile,
    bool embed_sources,
    ffi.Pointer<ffi.Char> package_config,
    Dart_KernelCompilationVerbosityLevel verbosity,
  ) {
    return _Dart_CompileToKernel(
      script_uri,
      platform_kernel,
      platform_kernel_size,
      incremental_compile,
      snapshot_compile,
      embed_sources,
      package_config,
      verbosity.value,
    );
  }

  late final _Dart_CompileToKernelPtr = _lookup<
      ffi.NativeFunction<
          Dart_KernelCompilationResult Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr,
              ffi.Bool,
              ffi.Bool,
              ffi.Bool,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('Dart_CompileToKernel');
  late final _Dart_CompileToKernel = _Dart_CompileToKernelPtr.asFunction<
      Dart_KernelCompilationResult Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Uint8>,
          int,
          bool,
          bool,
          bool,
          ffi.Pointer<ffi.Char>,
          int)>();

  Dart_KernelCompilationResult Dart_KernelListDependencies() {
    return _Dart_KernelListDependencies();
  }

  late final _Dart_KernelListDependenciesPtr =
      _lookup<ffi.NativeFunction<Dart_KernelCompilationResult Function()>>(
          'Dart_KernelListDependencies');
  late final _Dart_KernelListDependencies = _Dart_KernelListDependenciesPtr
      .asFunction<Dart_KernelCompilationResult Function()>();

  /// Sets the kernel buffer which will be used to load Dart SDK sources
  /// dynamically at runtime.
  ///
  /// \param platform_kernel A buffer containing kernel which has sources for the
  /// Dart SDK populated. Note: The VM does not take ownership of this memory.
  ///
  /// \param platform_kernel_size The length of the platform_kernel buffer.
  void Dart_SetDartLibrarySourcesKernel(
    ffi.Pointer<ffi.Uint8> platform_kernel,
    int platform_kernel_size,
  ) {
    return _Dart_SetDartLibrarySourcesKernel(
      platform_kernel,
      platform_kernel_size,
    );
  }

  late final _Dart_SetDartLibrarySourcesKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_SetDartLibrarySourcesKernel');
  late final _Dart_SetDartLibrarySourcesKernel =
      _Dart_SetDartLibrarySourcesKernelPtr.asFunction<
          void Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Always return true as the VM only supports strong null safety.
  bool Dart_DetectNullSafety(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Char> package_config,
    ffi.Pointer<ffi.Char> original_working_directory,
    ffi.Pointer<ffi.Uint8> snapshot_data,
    ffi.Pointer<ffi.Uint8> snapshot_instructions,
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_buffer_size,
  ) {
    return _Dart_DetectNullSafety(
      script_uri,
      package_config,
      original_working_directory,
      snapshot_data,
      snapshot_instructions,
      kernel_buffer,
      kernel_buffer_size,
    );
  }

  late final _Dart_DetectNullSafetyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_DetectNullSafety');
  late final _Dart_DetectNullSafety = _Dart_DetectNullSafetyPtr.asFunction<
      bool Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          int)>();

  /// Returns true if isolate is the service isolate.
  ///
  /// \param isolate An isolate
  ///
  /// \return Returns true if 'isolate' is the service isolate.
  bool Dart_IsServiceIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsServiceIsolate(
      isolate,
    );
  }

  late final _Dart_IsServiceIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Isolate)>>(
          'Dart_IsServiceIsolate');
  late final _Dart_IsServiceIsolate =
      _Dart_IsServiceIsolatePtr.asFunction<bool Function(Dart_Isolate)>();

  /// Writes the CPU profile to the timeline as a series of 'instant' events.
  ///
  /// Note that this is an expensive operation.
  ///
  /// \param main_port The main port of the Isolate whose profile samples to write.
  /// \param error An optional error, must be free()ed by caller.
  ///
  /// \return Returns true if the profile is successfully written and false
  /// otherwise.
  bool Dart_WriteProfileToTimeline(
    int main_port,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_WriteProfileToTimeline(
      main_port,
      error,
    );
  }

  late final _Dart_WriteProfileToTimelinePtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  Dart_Port, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'Dart_WriteProfileToTimeline');
  late final _Dart_WriteProfileToTimeline = _Dart_WriteProfileToTimelinePtr
      .asFunction<bool Function(int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Compiles all functions reachable from entry points and marks
  /// the isolate to disallow future compilation.
  ///
  /// Entry points should be specified using `@pragma("vm:entry-point")`
  /// annotation.
  ///
  /// \return An error handle if a compilation error or runtime error running const
  /// constructors was encountered.
  Object Dart_Precompile() {
    return _Dart_Precompile();
  }

  late final _Dart_PrecompilePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_Precompile');
  late final _Dart_Precompile =
      _Dart_PrecompilePtr.asFunction<Object Function()>();

  Object Dart_LoadingUnitLibraryUris(
    int loading_unit_id,
  ) {
    return _Dart_LoadingUnitLibraryUris(
      loading_unit_id,
    );
  }

  late final _Dart_LoadingUnitLibraryUrisPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.IntPtr)>>(
          'Dart_LoadingUnitLibraryUris');
  late final _Dart_LoadingUnitLibraryUris =
      _Dart_LoadingUnitLibraryUrisPtr.asFunction<Object Function(int)>();

  /// Creates a precompiled snapshot.
  /// - A root library must have been loaded.
  /// - Dart_Precompile must have been called.
  ///
  /// Outputs an assembly file defining the symbols listed in the definitions
  /// above.
  ///
  /// The assembly should be compiled as a static or shared library and linked or
  /// loaded by the embedder. Running this snapshot requires a VM compiled with
  /// DART_PRECOMPILED_SNAPSHOT. The kDartVmSnapshotData and
  /// kDartVmSnapshotInstructions should be passed to Dart_Initialize. The
  /// kDartIsolateSnapshotData and kDartIsolateSnapshotInstructions should be
  /// passed to Dart_CreateIsolateGroup.
  ///
  /// The callback will be invoked one or more times to provide the assembly code.
  ///
  /// If stripped is true, then the assembly code will not include DWARF
  /// debugging sections.
  ///
  /// If debug_callback_data is provided, debug_callback_data will be used with
  /// the callback to provide separate debugging information.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateAppAOTSnapshotAsAssembly(
    Dart_StreamingWriteCallback callback,
    ffi.Pointer<ffi.Void> callback_data,
    bool stripped,
    ffi.Pointer<ffi.Void> debug_callback_data,
  ) {
    return _Dart_CreateAppAOTSnapshotAsAssembly(
      callback,
      callback_data,
      stripped,
      debug_callback_data,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsAssemblyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              Dart_StreamingWriteCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
              ffi.Pointer<ffi.Void>)>>('Dart_CreateAppAOTSnapshotAsAssembly');
  late final _Dart_CreateAppAOTSnapshotAsAssembly =
      _Dart_CreateAppAOTSnapshotAsAssemblyPtr.asFunction<
          Object Function(Dart_StreamingWriteCallback, ffi.Pointer<ffi.Void>,
              bool, ffi.Pointer<ffi.Void>)>();

  Object Dart_CreateAppAOTSnapshotAsAssemblies(
    Dart_CreateLoadingUnitCallback next_callback,
    ffi.Pointer<ffi.Void> next_callback_data,
    bool stripped,
    Dart_StreamingWriteCallback write_callback,
    Dart_StreamingCloseCallback close_callback,
  ) {
    return _Dart_CreateAppAOTSnapshotAsAssemblies(
      next_callback,
      next_callback_data,
      stripped,
      write_callback,
      close_callback,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsAssembliesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_CreateLoadingUnitCallback,
                  ffi.Pointer<ffi.Void>,
                  ffi.Bool,
                  Dart_StreamingWriteCallback,
                  Dart_StreamingCloseCallback)>>(
      'Dart_CreateAppAOTSnapshotAsAssemblies');
  late final _Dart_CreateAppAOTSnapshotAsAssemblies =
      _Dart_CreateAppAOTSnapshotAsAssembliesPtr.asFunction<
          Object Function(
              Dart_CreateLoadingUnitCallback,
              ffi.Pointer<ffi.Void>,
              bool,
              Dart_StreamingWriteCallback,
              Dart_StreamingCloseCallback)>();

  /// Creates a precompiled snapshot.
  /// - A root library must have been loaded.
  /// - Dart_Precompile must have been called.
  ///
  /// Outputs an ELF shared library defining the symbols
  /// - _kDartVmSnapshotData
  /// - _kDartVmSnapshotInstructions
  /// - _kDartIsolateSnapshotData
  /// - _kDartIsolateSnapshotInstructions
  ///
  /// The shared library should be dynamically loaded by the embedder.
  /// Running this snapshot requires a VM compiled with DART_PRECOMPILED_SNAPSHOT.
  /// The kDartVmSnapshotData and kDartVmSnapshotInstructions should be passed to
  /// Dart_Initialize. The kDartIsolateSnapshotData and
  /// kDartIsolateSnapshotInstructions should be passed to Dart_CreateIsolate.
  ///
  /// The callback will be invoked one or more times to provide the binary output.
  ///
  /// If stripped is true, then the binary output will not include DWARF
  /// debugging sections.
  ///
  /// If debug_callback_data is provided, debug_callback_data will be used with
  /// the callback to provide separate debugging information.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateAppAOTSnapshotAsElf(
    Dart_StreamingWriteCallback callback,
    ffi.Pointer<ffi.Void> callback_data,
    bool stripped,
    ffi.Pointer<ffi.Void> debug_callback_data,
  ) {
    return _Dart_CreateAppAOTSnapshotAsElf(
      callback,
      callback_data,
      stripped,
      debug_callback_data,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsElfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              Dart_StreamingWriteCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
              ffi.Pointer<ffi.Void>)>>('Dart_CreateAppAOTSnapshotAsElf');
  late final _Dart_CreateAppAOTSnapshotAsElf =
      _Dart_CreateAppAOTSnapshotAsElfPtr.asFunction<
          Object Function(Dart_StreamingWriteCallback, ffi.Pointer<ffi.Void>,
              bool, ffi.Pointer<ffi.Void>)>();

  Object Dart_CreateAppAOTSnapshotAsElfs(
    Dart_CreateLoadingUnitCallback next_callback,
    ffi.Pointer<ffi.Void> next_callback_data,
    bool stripped,
    Dart_StreamingWriteCallback write_callback,
    Dart_StreamingCloseCallback close_callback,
  ) {
    return _Dart_CreateAppAOTSnapshotAsElfs(
      next_callback,
      next_callback_data,
      stripped,
      write_callback,
      close_callback,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsElfsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              Dart_CreateLoadingUnitCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
              Dart_StreamingWriteCallback,
              Dart_StreamingCloseCallback)>>('Dart_CreateAppAOTSnapshotAsElfs');
  late final _Dart_CreateAppAOTSnapshotAsElfs =
      _Dart_CreateAppAOTSnapshotAsElfsPtr.asFunction<
          Object Function(
              Dart_CreateLoadingUnitCallback,
              ffi.Pointer<ffi.Void>,
              bool,
              Dart_StreamingWriteCallback,
              Dart_StreamingCloseCallback)>();

  /// Like Dart_CreateAppAOTSnapshotAsAssembly, but only includes
  /// kDartVmSnapshotData and kDartVmSnapshotInstructions. It also does
  /// not strip DWARF information from the generated assembly or allow for
  /// separate debug information.
  Object Dart_CreateVMAOTSnapshotAsAssembly(
    Dart_StreamingWriteCallback callback,
    ffi.Pointer<ffi.Void> callback_data,
  ) {
    return _Dart_CreateVMAOTSnapshotAsAssembly(
      callback,
      callback_data,
    );
  }

  late final _Dart_CreateVMAOTSnapshotAsAssemblyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_StreamingWriteCallback,
              ffi.Pointer<ffi.Void>)>>('Dart_CreateVMAOTSnapshotAsAssembly');
  late final _Dart_CreateVMAOTSnapshotAsAssembly =
      _Dart_CreateVMAOTSnapshotAsAssemblyPtr.asFunction<
          Object Function(
              Dart_StreamingWriteCallback, ffi.Pointer<ffi.Void>)>();

  /// Sorts the class-ids in depth first traversal order of the inheritance
  /// tree. This is a costly operation, but it can make method dispatch
  /// more efficient and is done before writing snapshots.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_SortClasses() {
    return _Dart_SortClasses();
  }

  late final _Dart_SortClassesPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_SortClasses');
  late final _Dart_SortClasses =
      _Dart_SortClassesPtr.asFunction<Object Function()>();

  /// Creates a snapshot that caches compiled code and type feedback for faster
  /// startup and quicker warmup in a subsequent process.
  ///
  /// Outputs a snapshot in two pieces. The pieces should be passed to
  /// Dart_CreateIsolateGroup in a VM using the same VM snapshot pieces used in the
  /// current VM. The instructions piece must be loaded with read and execute
  /// permissions; the data piece may be loaded as read-only.
  ///
  /// - Requires the VM to have not been started with --precompilation.
  /// - Not supported when targeting IA32.
  /// - The VM writing the snapshot and the VM reading the snapshot must be the
  /// same version, must be built in the same DEBUG/RELEASE/PRODUCT mode, must
  /// be targeting the same architecture, and must both be in checked mode or
  /// both in unchecked mode.
  ///
  /// The buffers are scope allocated and are only valid until the next call to
  /// Dart_ExitScope.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateAppJITSnapshotAsBlobs(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_data_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_instructions_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_instructions_size,
  ) {
    return _Dart_CreateAppJITSnapshotAsBlobs(
      isolate_snapshot_data_buffer,
      isolate_snapshot_data_size,
      isolate_snapshot_instructions_buffer,
      isolate_snapshot_instructions_size,
    );
  }

  late final _Dart_CreateAppJITSnapshotAsBlobsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_CreateAppJITSnapshotAsBlobs');
  late final _Dart_CreateAppJITSnapshotAsBlobs =
      _Dart_CreateAppJITSnapshotAsBlobsPtr.asFunction<
          Object Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>();

  /// Get obfuscation map for precompiled code.
  ///
  /// Obfuscation map is encoded as a JSON array of pairs (original name,
  /// obfuscated name).
  ///
  /// \return Returns an error handler if the VM was built in a mode that does not
  /// support obfuscation.
  Object Dart_GetObfuscationMap(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> buffer,
    ffi.Pointer<ffi.IntPtr> buffer_length,
  ) {
    return _Dart_GetObfuscationMap(
      buffer,
      buffer_length,
    );
  }

  late final _Dart_GetObfuscationMapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetObfuscationMap');
  late final _Dart_GetObfuscationMap = _Dart_GetObfuscationMapPtr.asFunction<
      Object Function(
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ffi.IntPtr>)>();

  /// Returns whether the VM only supports running from precompiled snapshots and
  /// not from any other kind of snapshot or from source (that is, the VM was
  /// compiled with DART_PRECOMPILED_RUNTIME).
  bool Dart_IsPrecompiledRuntime() {
    return _Dart_IsPrecompiledRuntime();
  }

  late final _Dart_IsPrecompiledRuntimePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_IsPrecompiledRuntime');
  late final _Dart_IsPrecompiledRuntime =
      _Dart_IsPrecompiledRuntimePtr.asFunction<bool Function()>();

  /// Print a native stack trace. Used for crash handling.
  ///
  /// If context is NULL, prints the current stack trace. Otherwise, context
  /// should be a CONTEXT* (Windows) or ucontext_t* (POSIX) from a signal handler
  /// running on the current thread.
  void Dart_DumpNativeStackTrace(
    ffi.Pointer<ffi.Void> context,
  ) {
    return _Dart_DumpNativeStackTrace(
      context,
    );
  }

  late final _Dart_DumpNativeStackTracePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'Dart_DumpNativeStackTrace');
  late final _Dart_DumpNativeStackTrace = _Dart_DumpNativeStackTracePtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Indicate that the process is about to abort, and the Dart VM should not
  /// attempt to cleanup resources.
  void Dart_PrepareToAbort() {
    return _Dart_PrepareToAbort();
  }

  late final _Dart_PrepareToAbortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_PrepareToAbort');
  late final _Dart_PrepareToAbort =
      _Dart_PrepareToAbortPtr.asFunction<void Function()>();

  /// Configure DWARF stack trace footnote callback.
  void Dart_SetDwarfStackTraceFootnoteCallback(
    Dart_DwarfStackTraceFootnoteCallback callback,
  ) {
    return _Dart_SetDwarfStackTraceFootnoteCallback(
      callback,
    );
  }

  late final _Dart_SetDwarfStackTraceFootnoteCallbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(Dart_DwarfStackTraceFootnoteCallback)>>(
      'Dart_SetDwarfStackTraceFootnoteCallback');
  late final _Dart_SetDwarfStackTraceFootnoteCallback =
      _Dart_SetDwarfStackTraceFootnoteCallbackPtr.asFunction<
          void Function(Dart_DwarfStackTraceFootnoteCallback)>();

  int add(
    int a,
    int b,
  ) {
    return _add(
      a,
      b,
    );
  }

  late final _addPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('add');
  late final _add = _addPtr.asFunction<int Function(int, int)>();

  /// //////////////////////// Send Port  //////////////////////////////////////
  int InitDartApiDL(
    ffi.Pointer<ffi.Void> data,
  ) {
    return _InitDartApiDL(
      data,
    );
  }

  late final _InitDartApiDLPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>(
          'InitDartApiDL');
  late final _InitDartApiDL =
      _InitDartApiDLPtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  void nativeDartPortTestStartWork(
    int port,
  ) {
    return _nativeDartPortTestStartWork(
      port,
    );
  }

  late final _nativeDartPortTestStartWorkPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Dart_Port)>>(
          'nativeDartPortTestStartWork');
  late final _nativeDartPortTestStartWork =
      _nativeDartPortTestStartWorkPtr.asFunction<void Function(int)>();

  void nativeCallableTest(
    int x,
    nativeCallableTestCallbackType callback,
  ) {
    return _nativeCallableTest(
      x,
      callback,
    );
  }

  late final _nativeCallableTestPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int, nativeCallableTestCallbackType)>>('nativeCallableTest');
  late final _nativeCallableTest = _nativeCallableTestPtr
      .asFunction<void Function(int, nativeCallableTestCallbackType)>();

  /// //////////////////////// NativeCallable  /////////////////////////////////
  void nativeHttpGet(
    ffi.Pointer<ffi.Char> uri,
    NativeHttpCallback callback,
  ) {
    return _nativeHttpGet(
      uri,
      callback,
    );
  }

  late final _nativeHttpGetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Char>, NativeHttpCallback)>>('nativeHttpGet');
  late final _nativeHttpGet = _nativeHttpGetPtr
      .asFunction<void Function(ffi.Pointer<ffi.Char>, NativeHttpCallback)>();

  void nativeFree(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _nativeFree(
      ptr,
    );
  }

  late final _nativeFreePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'nativeFree');
  late final _nativeFree =
      _nativeFreePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
}

final class Dart_Isolate_ extends ffi.Opaque {}

/// An isolate is the unit of concurrency in Dart. Each isolate has
/// its own memory and thread of control. No state is shared between
/// isolates. Instead, isolates communicate by message passing.
///
/// Each thread keeps track of its current isolate, which is the
/// isolate which is ready to execute on the current thread. The
/// current isolate may be NULL, in which case no isolate is ready to
/// execute. Most of the Dart apis require there to be a current
/// isolate in order to function without error. The current isolate is
/// set by any call to Dart_CreateIsolateGroup or Dart_EnterIsolate.
typedef Dart_Isolate = ffi.Pointer<Dart_Isolate_>;

final class Dart_IsolateGroup_ extends ffi.Opaque {}

typedef Dart_IsolateGroup = ffi.Pointer<Dart_IsolateGroup_>;

final class Dart_Handle_ extends ffi.Opaque {}

final class Dart_WeakPersistentHandle_ extends ffi.Opaque {}

typedef Dart_WeakPersistentHandle = ffi.Pointer<Dart_WeakPersistentHandle_>;

final class Dart_FinalizableHandle_ extends ffi.Opaque {}

typedef Dart_FinalizableHandle = ffi.Pointer<Dart_FinalizableHandle_>;
typedef Dart_HandleFinalizerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> isolate_callback_data, ffi.Pointer<ffi.Void> peer);
typedef DartDart_HandleFinalizerFunction = void Function(
    ffi.Pointer<ffi.Void> isolate_callback_data, ffi.Pointer<ffi.Void> peer);
typedef Dart_HandleFinalizer
    = ffi.Pointer<ffi.NativeFunction<Dart_HandleFinalizerFunction>>;

final class Dart_IsolateFlags extends ffi.Struct {
  @ffi.Int32()
  external int version;

  @ffi.Bool()
  external bool enable_asserts;

  @ffi.Bool()
  external bool use_field_guards;

  @ffi.Bool()
  external bool use_osr;

  @ffi.Bool()
  external bool obfuscate;

  @ffi.Bool()
  external bool load_vmservice_library;

  @ffi.Bool()
  external bool null_safety;

  @ffi.Bool()
  external bool is_system_isolate;

  @ffi.Bool()
  external bool is_service_isolate;

  @ffi.Bool()
  external bool is_kernel_isolate;

  @ffi.Bool()
  external bool snapshot_is_dontneed_safe;

  @ffi.Bool()
  external bool branch_coverage;

  @ffi.Bool()
  external bool coverage;
}

typedef Dart_IsolateGroupCreateCallbackFunction = Dart_Isolate Function(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Char> main,
    ffi.Pointer<ffi.Char> package_root,
    ffi.Pointer<ffi.Char> package_config,
    ffi.Pointer<Dart_IsolateFlags> flags,
    ffi.Pointer<ffi.Void> isolate_data,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error);

/// An isolate creation and initialization callback function.
///
/// This callback, provided by the embedder, is called when the VM
/// needs to create an isolate. The callback should create an isolate
/// by calling Dart_CreateIsolateGroup and load any scripts required for
/// execution.
///
/// This callback may be called on a different thread than the one
/// running the parent isolate.
///
/// When the function returns NULL, it is the responsibility of this
/// function to ensure that Dart_ShutdownIsolate has been called if
/// required (for example, if the isolate was created successfully by
/// Dart_CreateIsolateGroup() but the root library fails to load
/// successfully, then the function should call Dart_ShutdownIsolate
/// before returning).
///
/// When the function returns NULL, the function should set *error to
/// a malloc-allocated buffer containing a useful error message.  The
/// caller of this function (the VM) will make sure that the buffer is
/// freed.
///
/// \param script_uri The uri of the main source file or snapshot to load.
/// Either the URI of the parent isolate set in Dart_CreateIsolateGroup for
/// Isolate.spawn, or the argument to Isolate.spawnUri canonicalized by the
/// library tag handler of the parent isolate.
/// The callback is responsible for loading the program by a call to
/// Dart_LoadScriptFromKernel.
/// \param main The name of the main entry point this isolate will
/// eventually run.  This is provided for advisory purposes only to
/// improve debugging messages.  The main function is not invoked by
/// this function.
/// \param package_root Ignored.
/// \param package_config Uri of the package configuration file (either in format
/// of .packages or .dart_tool/package_config.json) for this isolate
/// to resolve package imports against. If this parameter is not passed the
/// package resolution of the parent isolate should be used.
/// \param flags Default flags for this isolate being spawned. Either inherited
/// from the spawning isolate or passed as parameters when spawning the
/// isolate from Dart code.
/// \param isolate_data The isolate data which was passed to the
/// parent isolate when it was created by calling Dart_CreateIsolateGroup().
/// \param error A structure into which the embedder can place a
/// C string containing an error message in the case of failures.
///
/// \return The embedder returns NULL if the creation and
/// initialization was not successful and the isolate if successful.
typedef Dart_IsolateGroupCreateCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_IsolateGroupCreateCallbackFunction>>;
typedef Dart_InitializeIsolateCallbackFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Pointer<ffi.Void>> child_isolate_data,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error);
typedef DartDart_InitializeIsolateCallbackFunction = bool Function(
    ffi.Pointer<ffi.Pointer<ffi.Void>> child_isolate_data,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error);

/// An isolate initialization callback function.
///
/// This callback, provided by the embedder, is called when the VM has created an
/// isolate within an existing isolate group (i.e. from the same source as an
/// existing isolate).
///
/// The callback should setup native resolvers and might want to set a custom
/// message handler via [Dart_SetMessageNotifyCallback] and mark the isolate as
/// runnable.
///
/// This callback may be called on a different thread than the one
/// running the parent isolate.
///
/// When the function returns `false`, it is the responsibility of this
/// function to ensure that `Dart_ShutdownIsolate` has been called.
///
/// When the function returns `false`, the function should set *error to
/// a malloc-allocated buffer containing a useful error message.  The
/// caller of this function (the VM) will make sure that the buffer is
/// freed.
///
/// \param child_isolate_data The callback data to associate with the new
/// child isolate.
/// \param error A structure into which the embedder can place a
/// C string containing an error message in the case the initialization fails.
///
/// \return The embedder returns true if the initialization was successful and
/// false otherwise (in which case the VM will terminate the isolate).
typedef Dart_InitializeIsolateCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_InitializeIsolateCallbackFunction>>;
typedef Dart_IsolateShutdownCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> isolate_group_data,
    ffi.Pointer<ffi.Void> isolate_data);
typedef DartDart_IsolateShutdownCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> isolate_group_data,
    ffi.Pointer<ffi.Void> isolate_data);

/// An isolate shutdown callback function.
///
/// This callback, provided by the embedder, is called before the vm
/// shuts down an isolate.  The isolate being shutdown will be the current
/// isolate. It is safe to run Dart code.
///
/// This function should be used to dispose of native resources that
/// are allocated to an isolate in order to avoid leaks.
///
/// \param isolate_group_data The same callback data which was passed to the
/// isolate group when it was created.
/// \param isolate_data The same callback data which was passed to the isolate
/// when it was created.
typedef Dart_IsolateShutdownCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_IsolateShutdownCallbackFunction>>;
typedef Dart_IsolateCleanupCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> isolate_group_data,
    ffi.Pointer<ffi.Void> isolate_data);
typedef DartDart_IsolateCleanupCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> isolate_group_data,
    ffi.Pointer<ffi.Void> isolate_data);

/// An isolate cleanup callback function.
///
/// This callback, provided by the embedder, is called after the vm
/// shuts down an isolate. There will be no current isolate and it is *not*
/// safe to run Dart code.
///
/// This function should be used to dispose of native resources that
/// are allocated to an isolate in order to avoid leaks.
///
/// \param isolate_group_data The same callback data which was passed to the
/// isolate group when it was created.
/// \param isolate_data The same callback data which was passed to the isolate
/// when it was created.
typedef Dart_IsolateCleanupCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_IsolateCleanupCallbackFunction>>;
typedef Dart_IsolateGroupCleanupCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> isolate_group_data);
typedef DartDart_IsolateGroupCleanupCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> isolate_group_data);

/// An isolate group cleanup callback function.
///
/// This callback, provided by the embedder, is called after the vm
/// shuts down an isolate group.
///
/// This function should be used to dispose of native resources that
/// are allocated to an isolate in order to avoid leaks.
///
/// \param isolate_group_data The same callback data which was passed to the
/// isolate group when it was created.
typedef Dart_IsolateGroupCleanupCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_IsolateGroupCleanupCallbackFunction>>;
typedef Dart_ThreadStartCallbackFunction = ffi.Void Function();
typedef DartDart_ThreadStartCallbackFunction = void Function();

/// A thread start callback function.
/// This callback, provided by the embedder, is called after a thread in the
/// vm thread pool starts.
/// This function could be used to adjust thread priority or attach native
/// resources to the thread.
typedef Dart_ThreadStartCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_ThreadStartCallbackFunction>>;
typedef Dart_ThreadExitCallbackFunction = ffi.Void Function();
typedef DartDart_ThreadExitCallbackFunction = void Function();

/// A thread death callback function.
/// This callback, provided by the embedder, is called before a thread in the
/// vm thread pool exits.
/// This function could be used to dispose of native resources that
/// are associated and attached to the thread, in order to avoid leaks.
typedef Dart_ThreadExitCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_ThreadExitCallbackFunction>>;
typedef Dart_FileOpenCallbackFunction = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Char> name, ffi.Bool write);
typedef DartDart_FileOpenCallbackFunction = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Char> name, bool write);

/// Opens a file for reading or writing.
///
/// Callback provided by the embedder for file operations. If the
/// embedder does not allow file operations this callback can be
/// NULL.
///
/// \param name The name of the file to open.
/// \param write A boolean variable which indicates if the file is to
/// opened for writing. If there is an existing file it needs to truncated.
typedef Dart_FileOpenCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_FileOpenCallbackFunction>>;
typedef Dart_FileReadCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.IntPtr> file_length,
    ffi.Pointer<ffi.Void> stream);
typedef DartDart_FileReadCallbackFunction = void Function(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.IntPtr> file_length,
    ffi.Pointer<ffi.Void> stream);

/// Read contents of file.
///
/// Callback provided by the embedder for file operations. If the
/// embedder does not allow file operations this callback can be
/// NULL.
///
/// \param data Buffer allocated in the callback into which the contents
/// of the file are read into. It is the responsibility of the caller to
/// free this buffer.
/// \param file_length A variable into which the length of the file is returned.
/// In the case of an error this value would be -1.
/// \param stream Handle to the opened file.
typedef Dart_FileReadCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_FileReadCallbackFunction>>;
typedef Dart_FileWriteCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> data,
    ffi.IntPtr length,
    ffi.Pointer<ffi.Void> stream);
typedef DartDart_FileWriteCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> data, int length, ffi.Pointer<ffi.Void> stream);

/// Write data into file.
///
/// Callback provided by the embedder for file operations. If the
/// embedder does not allow file operations this callback can be
/// NULL.
///
/// \param data Buffer which needs to be written into the file.
/// \param length Length of the buffer.
/// \param stream Handle to the opened file.
typedef Dart_FileWriteCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_FileWriteCallbackFunction>>;
typedef Dart_FileCloseCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> stream);
typedef DartDart_FileCloseCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> stream);

/// Closes the opened file.
///
/// Callback provided by the embedder for file operations. If the
/// embedder does not allow file operations this callback can be
/// NULL.
///
/// \param stream Handle to the opened file.
typedef Dart_FileCloseCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_FileCloseCallbackFunction>>;
typedef Dart_EntropySourceFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Uint8> buffer, ffi.IntPtr length);
typedef DartDart_EntropySourceFunction = bool Function(
    ffi.Pointer<ffi.Uint8> buffer, int length);
typedef Dart_EntropySource
    = ffi.Pointer<ffi.NativeFunction<Dart_EntropySourceFunction>>;
typedef Dart_GetVMServiceAssetsArchiveFunction = ffi.Handle Function();
typedef DartDart_GetVMServiceAssetsArchiveFunction = Object Function();

/// Callback provided by the embedder that is used by the vmservice isolate
/// to request the asset archive. The asset archive must be an uncompressed tar
/// archive that is stored in a Uint8List.
///
/// If the embedder has no vmservice isolate assets, the callback can be NULL.
///
/// \return The embedder must return a handle to a Uint8List containing an
/// uncompressed tar archive or null.
typedef Dart_GetVMServiceAssetsArchive
    = ffi.Pointer<ffi.NativeFunction<Dart_GetVMServiceAssetsArchiveFunction>>;
typedef Dart_OnNewCodeCallbackFunction = ffi.Void Function(
    ffi.Pointer<Dart_CodeObserver> observer,
    ffi.Pointer<ffi.Char> name,
    ffi.UintPtr base,
    ffi.UintPtr size);
typedef DartDart_OnNewCodeCallbackFunction = void Function(
    ffi.Pointer<Dart_CodeObserver> observer,
    ffi.Pointer<ffi.Char> name,
    int base,
    int size);

/// Callback provided by the embedder that is used by the VM to notify on code
/// object creation, *before* it is invoked the first time.
/// This is useful for embedders wanting to e.g. keep track of PCs beyond
/// the lifetime of the garbage collected code objects.
/// Note that an address range may be used by more than one code object over the
/// lifecycle of a process. Clients of this function should record timestamps for
/// these compilation events and when collecting PCs to disambiguate reused
/// address ranges.
typedef Dart_OnNewCodeCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_OnNewCodeCallbackFunction>>;

/// Forward declaration
final class Dart_CodeObserver extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  external Dart_OnNewCodeCallback on_new_code;
}

/// Describes how to initialize the VM. Used with Dart_Initialize.
final class Dart_InitializeParams extends ffi.Struct {
  /// Identifies the version of the struct used by the client.
  /// should be initialized to DART_INITIALIZE_PARAMS_CURRENT_VERSION.
  @ffi.Int32()
  external int version;

  /// A buffer containing snapshot data, or NULL if no snapshot is provided.
  ///
  /// If provided, the buffer must remain valid until Dart_Cleanup returns.
  external ffi.Pointer<ffi.Uint8> vm_snapshot_data;

  /// A buffer containing a snapshot of precompiled instructions, or NULL if
  /// no snapshot is provided.
  ///
  /// If provided, the buffer must remain valid until Dart_Cleanup returns.
  external ffi.Pointer<ffi.Uint8> vm_snapshot_instructions;

  /// A function to be called during isolate group creation.
  /// See Dart_IsolateGroupCreateCallback.
  external Dart_IsolateGroupCreateCallback create_group;

  /// A function to be called during isolate
  /// initialization inside an existing isolate group.
  /// See Dart_InitializeIsolateCallback.
  external Dart_InitializeIsolateCallback initialize_isolate;

  /// A function to be called right before an isolate is shutdown.
  /// See Dart_IsolateShutdownCallback.
  external Dart_IsolateShutdownCallback shutdown_isolate;

  /// A function to be called after an isolate was shutdown.
  /// See Dart_IsolateCleanupCallback.
  external Dart_IsolateCleanupCallback cleanup_isolate;

  /// A function to be called after an isolate group is
  /// shutdown. See Dart_IsolateGroupCleanupCallback.
  external Dart_IsolateGroupCleanupCallback cleanup_group;

  external Dart_ThreadStartCallback thread_start;

  external Dart_ThreadExitCallback thread_exit;

  external Dart_FileOpenCallback file_open;

  external Dart_FileReadCallback file_read;

  external Dart_FileWriteCallback file_write;

  external Dart_FileCloseCallback file_close;

  external Dart_EntropySource entropy_source;

  /// A function to be called by the service isolate when it requires the
  /// vmservice assets archive. See Dart_GetVMServiceAssetsArchive.
  external Dart_GetVMServiceAssetsArchive get_service_assets;

  @ffi.Bool()
  external bool start_kernel_isolate;

  /// An external code observer callback function. The observer can be invoked
  /// as early as during the Dart_Initialize() call.
  external ffi.Pointer<Dart_CodeObserver> code_observer;
}

/// Gets an id that uniquely identifies current isolate group.
///
/// It is the responsibility of the caller to free the returned ID.
typedef Dart_IsolateGroupId = ffi.Int64;
typedef DartDart_IsolateGroupId = int;
typedef Dart_HeapSamplingReportCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.Void> data);
typedef DartDart_HeapSamplingReportCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.Void> data);
typedef Dart_HeapSamplingReportCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_HeapSamplingReportCallbackFunction>>;
typedef Dart_HeapSamplingCreateCallbackFunction
    = ffi.Pointer<ffi.Void> Function(
        Dart_Isolate isolate,
        Dart_IsolateGroup isolate_group,
        ffi.Pointer<ffi.Char> cls_name,
        ffi.IntPtr allocation_size);
typedef DartDart_HeapSamplingCreateCallbackFunction
    = ffi.Pointer<ffi.Void> Function(
        Dart_Isolate isolate,
        Dart_IsolateGroup isolate_group,
        ffi.Pointer<ffi.Char> cls_name,
        int allocation_size);
typedef Dart_HeapSamplingCreateCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_HeapSamplingCreateCallbackFunction>>;
typedef Dart_HeapSamplingDeleteCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> data);
typedef DartDart_HeapSamplingDeleteCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> data);
typedef Dart_HeapSamplingDeleteCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_HeapSamplingDeleteCallbackFunction>>;

enum Dart_PerformanceMode {
  /// Balanced
  Dart_PerformanceMode_Default(0),

  /// Optimize for low latency, at the expense of throughput and memory overhead
  /// by performing work in smaller batches (requiring more overhead) or by
  /// delaying work (requiring more memory). An embedder should not remain in
  /// this mode indefinitely.
  Dart_PerformanceMode_Latency(1),

  /// Optimize for high throughput, at the expense of latency and memory overhead
  /// by performing work in larger batches with more intervening growth.
  Dart_PerformanceMode_Throughput(2),

  /// Optimize for low memory, at the expensive of throughput and latency by more
  /// frequently performing work.
  Dart_PerformanceMode_Memory(3);

  final int value;
  const Dart_PerformanceMode(this.value);

  static Dart_PerformanceMode fromValue(int value) => switch (value) {
        0 => Dart_PerformanceMode_Default,
        1 => Dart_PerformanceMode_Latency,
        2 => Dart_PerformanceMode_Throughput,
        3 => Dart_PerformanceMode_Memory,
        _ =>
          throw ArgumentError('Unknown value for Dart_PerformanceMode: $value'),
      };
}

/// A port is used to send or receive inter-isolate messages
typedef Dart_Port = ffi.Int64;
typedef DartDart_Port = int;

final class Dart_PortEx extends ffi.Struct {
  @ffi.Int64()
  external int port_id;

  @ffi.Int64()
  external int origin_id;
}

typedef Dart_MessageNotifyCallbackFunction = ffi.Void Function(
    Dart_Isolate destination_isolate);
typedef DartDart_MessageNotifyCallbackFunction = void Function(
    Dart_Isolate destination_isolate);

/// A message notification callback.
///
/// This callback allows the embedder to provide a custom wakeup mechanism for
/// the delivery of inter-isolate messages. This function is called once per
/// message on an arbitrary thread. It is the responsibility of the embedder to
/// eventually call Dart_HandleMessage once per callback received with the
/// destination isolate set as the current isolate to process the message.
typedef Dart_MessageNotifyCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_MessageNotifyCallbackFunction>>;

enum Dart_TypedData_Type {
  Dart_TypedData_kByteData(0),
  Dart_TypedData_kInt8(1),
  Dart_TypedData_kUint8(2),
  Dart_TypedData_kUint8Clamped(3),
  Dart_TypedData_kInt16(4),
  Dart_TypedData_kUint16(5),
  Dart_TypedData_kInt32(6),
  Dart_TypedData_kUint32(7),
  Dart_TypedData_kInt64(8),
  Dart_TypedData_kUint64(9),
  Dart_TypedData_kFloat32(10),
  Dart_TypedData_kFloat64(11),
  Dart_TypedData_kInt32x4(12),
  Dart_TypedData_kFloat32x4(13),
  Dart_TypedData_kFloat64x2(14),
  Dart_TypedData_kInvalid(15);

  final int value;
  const Dart_TypedData_Type(this.value);

  static Dart_TypedData_Type fromValue(int value) => switch (value) {
        0 => Dart_TypedData_kByteData,
        1 => Dart_TypedData_kInt8,
        2 => Dart_TypedData_kUint8,
        3 => Dart_TypedData_kUint8Clamped,
        4 => Dart_TypedData_kInt16,
        5 => Dart_TypedData_kUint16,
        6 => Dart_TypedData_kInt32,
        7 => Dart_TypedData_kUint32,
        8 => Dart_TypedData_kInt64,
        9 => Dart_TypedData_kUint64,
        10 => Dart_TypedData_kFloat32,
        11 => Dart_TypedData_kFloat64,
        12 => Dart_TypedData_kInt32x4,
        13 => Dart_TypedData_kFloat32x4,
        14 => Dart_TypedData_kFloat64x2,
        15 => Dart_TypedData_kInvalid,
        _ =>
          throw ArgumentError('Unknown value for Dart_TypedData_Type: $value'),
      };
}

final class Dart_NativeArguments_ extends ffi.Opaque {}

/// The arguments to a native function.
///
/// This object is passed to a native function to represent its
/// arguments and return value. It allows access to the arguments to a
/// native function by index. It also allows the return value of a
/// native function to be set.
typedef Dart_NativeArguments = ffi.Pointer<Dart_NativeArguments_>;

enum Dart_NativeArgument_Type {
  Dart_NativeArgument_kBool(0),
  Dart_NativeArgument_kInt32(1),
  Dart_NativeArgument_kUint32(2),
  Dart_NativeArgument_kInt64(3),
  Dart_NativeArgument_kUint64(4),
  Dart_NativeArgument_kDouble(5),
  Dart_NativeArgument_kString(6),
  Dart_NativeArgument_kInstance(7),
  Dart_NativeArgument_kNativeFields(8);

  final int value;
  const Dart_NativeArgument_Type(this.value);

  static Dart_NativeArgument_Type fromValue(int value) => switch (value) {
        0 => Dart_NativeArgument_kBool,
        1 => Dart_NativeArgument_kInt32,
        2 => Dart_NativeArgument_kUint32,
        3 => Dart_NativeArgument_kInt64,
        4 => Dart_NativeArgument_kUint64,
        5 => Dart_NativeArgument_kDouble,
        6 => Dart_NativeArgument_kString,
        7 => Dart_NativeArgument_kInstance,
        8 => Dart_NativeArgument_kNativeFields,
        _ => throw ArgumentError(
            'Unknown value for Dart_NativeArgument_Type: $value'),
      };
}

final class Dart_NativeArgument_Descriptor_ extends ffi.Struct {
  @ffi.Uint8()
  external int type;

  @ffi.Uint8()
  external int index;
}

typedef Dart_NativeArgument_Descriptor = Dart_NativeArgument_Descriptor_;

final class _Dart_NativeArgument_Value extends ffi.Opaque {}

typedef Dart_NativeArgument_Value = _Dart_NativeArgument_Value;
typedef Dart_NativeFunctionFunction = ffi.Void Function(
    Dart_NativeArguments arguments);
typedef DartDart_NativeFunctionFunction = void Function(
    Dart_NativeArguments arguments);

/// A native function.
typedef Dart_NativeFunction
    = ffi.Pointer<ffi.NativeFunction<Dart_NativeFunctionFunction>>;
typedef Dart_NativeEntryResolverFunction = Dart_NativeFunction Function(
    ffi.Handle name,
    ffi.Int num_of_arguments,
    ffi.Pointer<ffi.Bool> auto_setup_scope);
typedef DartDart_NativeEntryResolverFunction = Dart_NativeFunction Function(
    Object name, int num_of_arguments, ffi.Pointer<ffi.Bool> auto_setup_scope);

/// Native entry resolution callback.
///
/// For libraries and scripts which have native functions, the embedder
/// can provide a native entry resolver. This callback is used to map a
/// name/arity to a Dart_NativeFunction. If no function is found, the
/// callback should return NULL.
///
/// The parameters to the native resolver function are:
/// \param name a Dart string which is the name of the native function.
/// \param num_of_arguments is the number of arguments expected by the
/// native function.
/// \param auto_setup_scope is a boolean flag that can be set by the resolver
/// to indicate if this function needs a Dart API scope (see Dart_EnterScope/
/// Dart_ExitScope) to be setup automatically by the VM before calling into
/// the native function. By default most native functions would require this
/// to be true but some light weight native functions which do not call back
/// into the VM through the Dart API may not require a Dart scope to be
/// setup automatically.
///
/// \return A valid Dart_NativeFunction which resolves to a native entry point
/// for the native function.
///
/// See Dart_SetNativeResolver.
typedef Dart_NativeEntryResolver
    = ffi.Pointer<ffi.NativeFunction<Dart_NativeEntryResolverFunction>>;
typedef Dart_NativeEntrySymbolFunction = ffi.Pointer<ffi.Uint8> Function(
    Dart_NativeFunction nf);

/// Native entry symbol lookup callback.
///
/// For libraries and scripts which have native functions, the embedder
/// can provide a callback for mapping a native entry to a symbol. This callback
/// maps a native function entry PC to the native function name. If no native
/// entry symbol can be found, the callback should return NULL.
///
/// The parameters to the native reverse resolver function are:
/// \param nf A Dart_NativeFunction.
///
/// \return A const UTF-8 string containing the symbol name or NULL.
///
/// See Dart_SetNativeResolver.
typedef Dart_NativeEntrySymbol
    = ffi.Pointer<ffi.NativeFunction<Dart_NativeEntrySymbolFunction>>;
typedef Dart_FfiNativeResolverFunction = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Char> name, ffi.UintPtr args_n);
typedef DartDart_FfiNativeResolverFunction = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Char> name, int args_n);

/// FFI Native C function pointer resolver callback.
///
/// See Dart_SetFfiNativeResolver.
typedef Dart_FfiNativeResolver
    = ffi.Pointer<ffi.NativeFunction<Dart_FfiNativeResolverFunction>>;
typedef Dart_EnvironmentCallbackFunction = ffi.Handle Function(ffi.Handle name);
typedef DartDart_EnvironmentCallbackFunction = Object Function(Object name);

/// An environment lookup callback function.
///
/// \param name The name of the value to lookup in the environment.
///
/// \return A valid handle to a string if the name exists in the
/// current environment or Dart_Null() if not.
typedef Dart_EnvironmentCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_EnvironmentCallbackFunction>>;
typedef Dart_NativeAssetsDlopenCallbackFunction
    = ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<ffi.Char> path, ffi.Pointer<ffi.Pointer<ffi.Char>> error);

/// Callback provided by the embedder that is used by the VM to resolve asset
/// paths.
///
/// The VM is responsible for looking up the asset path with the asset id in the
/// kernel mapping. The embedder is responsible for providing the asset mapping
/// during kernel compilation and using the asset path to return a library handle
/// in this function.
///
/// \param path The string in the asset path as passed in native_assets.yaml
/// during kernel compilation.
///
/// \param error Returns NULL if successful, an error message otherwise. The
/// caller is responsible for calling free() on the error message.
///
/// \return The library handle. If |error| is not-null, the return value is
/// undefined.
typedef Dart_NativeAssetsDlopenCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_NativeAssetsDlopenCallbackFunction>>;
typedef Dart_NativeAssetsDlopenCallbackNoPathFunction = ffi.Pointer<ffi.Void>
    Function(ffi.Pointer<ffi.Pointer<ffi.Char>> error);
typedef Dart_NativeAssetsDlopenCallbackNoPath = ffi
    .Pointer<ffi.NativeFunction<Dart_NativeAssetsDlopenCallbackNoPathFunction>>;
typedef Dart_NativeAssetsDlopenAssetIdFunction = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Char> asset_id, ffi.Pointer<ffi.Pointer<ffi.Char>> error);

/// Callback provided by the embedder that is used by the VM to resolve asset
/// ids.
///
/// The embedder can freely chose how to bundle asset id to asset path mappings
/// and how to perform this lookup.
///
/// If the embedder provides this callback, it must also provide
/// `Dart_NativeAssetsAvailableAssets`.
///
/// If provided, takes prescedence over `Dart_NativeAssetsDlopenCallback`.
///
/// \param path The asset id requested in the `@Native` external function.
///
/// \param error Returns NULL if successful, an error message otherwise. The
/// caller is responsible for calling free() on the error message.
///
/// \return The library handle. If |error| is not-null, the return value is
/// undefined.
typedef Dart_NativeAssetsDlopenAssetId
    = ffi.Pointer<ffi.NativeFunction<Dart_NativeAssetsDlopenAssetIdFunction>>;
typedef Dart_NativeAssetsAvailableAssetsFunction = ffi.Pointer<ffi.Char>
    Function();

/// Callback provided by the embedder that is used  by the VM to request a
/// description of the available assets
///
/// \return A malloced string containing all asset ids. The caller must free this
/// string.
typedef Dart_NativeAssetsAvailableAssets
    = ffi.Pointer<ffi.NativeFunction<Dart_NativeAssetsAvailableAssetsFunction>>;
typedef Dart_NativeAssetsDlsymCallbackFunction = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void> handle,
    ffi.Pointer<ffi.Char> symbol,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error);

/// Callback provided by the embedder that is used by the VM to lookup symbols
/// in native code assets.
/// If no callback is provided, using `@Native`s with `native_asset.yaml`s will
/// fail.
///
/// \param handle The library handle returned from a
/// `Dart_NativeAssetsDlopenCallback` or
/// `Dart_NativeAssetsDlopenCallbackNoPath`.
///
/// \param symbol The symbol to look up. Is a string.
///
/// \param error Returns NULL if creation is successful, an error message
/// otherwise. The caller is responsible for calling free() on the error
/// message.
///
/// \return The symbol address. If |error| is not-null, the return value is
/// undefined.
typedef Dart_NativeAssetsDlsymCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_NativeAssetsDlsymCallbackFunction>>;

final class NativeAssetsApi extends ffi.Struct {
  external Dart_NativeAssetsDlopenCallback dlopen_absolute;

  external Dart_NativeAssetsDlopenCallback dlopen_relative;

  external Dart_NativeAssetsDlopenCallback dlopen_system;

  external Dart_NativeAssetsDlopenCallbackNoPath dlopen_process;

  external Dart_NativeAssetsDlopenCallbackNoPath dlopen_executable;

  external Dart_NativeAssetsDlsymCallback dlsym;

  external Dart_NativeAssetsDlopenAssetId dlopen;

  external Dart_NativeAssetsAvailableAssets available_assets;
}

enum Dart_LibraryTag {
  Dart_kCanonicalizeUrl(0),
  Dart_kImportTag(1),
  Dart_kKernelTag(2);

  final int value;
  const Dart_LibraryTag(this.value);

  static Dart_LibraryTag fromValue(int value) => switch (value) {
        0 => Dart_kCanonicalizeUrl,
        1 => Dart_kImportTag,
        2 => Dart_kKernelTag,
        _ => throw ArgumentError('Unknown value for Dart_LibraryTag: $value'),
      };
}

typedef Dart_LibraryTagHandlerFunction = ffi.Handle Function(
    ffi.UnsignedInt tag, ffi.Handle library_or_package_map_url, ffi.Handle url);
typedef DartDart_LibraryTagHandlerFunction = Object Function(
    Dart_LibraryTag tag, Object library_or_package_map_url, Object url);

/// The library tag handler is a multi-purpose callback provided by the
/// embedder to the Dart VM. The embedder implements the tag handler to
/// provide the ability to load Dart scripts and imports.
///
/// -- TAGS --
///
/// Dart_kCanonicalizeUrl
///
/// This tag indicates that the embedder should canonicalize 'url' with
/// respect to 'library'.  For most embedders, this is resolving the `url`
/// relative to the `library`s url (see `Dart_LibraryUrl`).
///
/// Dart_kImportTag
///
/// This tag is used to load a library from IsolateMirror.loadUri. The embedder
/// should call Dart_LoadLibraryFromKernel to provide the library to the VM. The
/// return value should be an error or library (the result from
/// Dart_LoadLibraryFromKernel).
///
/// Dart_kKernelTag
///
/// This tag is used to load the intermediate file (kernel) generated by
/// the Dart front end. This tag is typically used when a 'hot-reload'
/// of an application is needed and the VM is 'use dart front end' mode.
/// The dart front end typically compiles all the scripts, imports and part
/// files into one intermediate file hence we don't use the source/import or
/// script tags. The return value should be an error or a TypedData containing
/// the kernel bytes.
typedef Dart_LibraryTagHandler
    = ffi.Pointer<ffi.NativeFunction<Dart_LibraryTagHandlerFunction>>;
typedef Dart_DeferredLoadHandlerFunction = ffi.Handle Function(
    ffi.IntPtr loading_unit_id);
typedef DartDart_DeferredLoadHandlerFunction = Object Function(
    int loading_unit_id);

/// Handles deferred loading requests. When this handler is invoked, it should
/// eventually load the deferred loading unit with the given id and call
/// Dart_DeferredLoadComplete or Dart_DeferredLoadCompleteError. It is
/// recommended that the loading occur asynchronously, but it is permitted to
/// call Dart_DeferredLoadComplete or Dart_DeferredLoadCompleteError before the
/// handler returns.
///
/// If an error is returned, it will be propagated through
/// `prefix.loadLibrary()`. This is useful for synchronous
/// implementations, which must propagate any unwind errors from
/// Dart_DeferredLoadComplete or Dart_DeferredLoadComplete. Otherwise the handler
/// should return a non-error such as `Dart_Null()`.
typedef Dart_DeferredLoadHandler
    = ffi.Pointer<ffi.NativeFunction<Dart_DeferredLoadHandlerFunction>>;

/// Experimental support for Dart to Kernel parser isolate.
enum Dart_KernelCompilationStatus {
  Dart_KernelCompilationStatus_Unknown(-1),
  Dart_KernelCompilationStatus_Ok(0),
  Dart_KernelCompilationStatus_Error(1),
  Dart_KernelCompilationStatus_Crash(2),
  Dart_KernelCompilationStatus_MsgFailed(3);

  final int value;
  const Dart_KernelCompilationStatus(this.value);

  static Dart_KernelCompilationStatus fromValue(int value) => switch (value) {
        -1 => Dart_KernelCompilationStatus_Unknown,
        0 => Dart_KernelCompilationStatus_Ok,
        1 => Dart_KernelCompilationStatus_Error,
        2 => Dart_KernelCompilationStatus_Crash,
        3 => Dart_KernelCompilationStatus_MsgFailed,
        _ => throw ArgumentError(
            'Unknown value for Dart_KernelCompilationStatus: $value'),
      };
}

final class Dart_KernelCompilationResult extends ffi.Struct {
  @ffi.Int()
  external int statusAsInt;

  Dart_KernelCompilationStatus get status =>
      Dart_KernelCompilationStatus.fromValue(statusAsInt);

  external ffi.Pointer<ffi.Char> error;

  external ffi.Pointer<ffi.Uint8> kernel;

  @ffi.IntPtr()
  external int kernel_size;
}

enum Dart_KernelCompilationVerbosityLevel {
  Dart_KernelCompilationVerbosityLevel_Error(0),
  Dart_KernelCompilationVerbosityLevel_Warning(1),
  Dart_KernelCompilationVerbosityLevel_Info(2),
  Dart_KernelCompilationVerbosityLevel_All(3);

  final int value;
  const Dart_KernelCompilationVerbosityLevel(this.value);

  static Dart_KernelCompilationVerbosityLevel fromValue(int value) =>
      switch (value) {
        0 => Dart_KernelCompilationVerbosityLevel_Error,
        1 => Dart_KernelCompilationVerbosityLevel_Warning,
        2 => Dart_KernelCompilationVerbosityLevel_Info,
        3 => Dart_KernelCompilationVerbosityLevel_All,
        _ => throw ArgumentError(
            'Unknown value for Dart_KernelCompilationVerbosityLevel: $value'),
      };
}

final class Dart_SourceFile extends ffi.Struct {
  external ffi.Pointer<ffi.Char> uri;

  external ffi.Pointer<ffi.Char> source;
}

typedef Dart_CreateLoadingUnitCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> callback_data,
    ffi.IntPtr loading_unit_id,
    ffi.Pointer<ffi.Pointer<ffi.Void>> write_callback_data,
    ffi.Pointer<ffi.Pointer<ffi.Void>> write_debug_callback_data);
typedef DartDart_CreateLoadingUnitCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> callback_data,
    int loading_unit_id,
    ffi.Pointer<ffi.Pointer<ffi.Void>> write_callback_data,
    ffi.Pointer<ffi.Pointer<ffi.Void>> write_debug_callback_data);
typedef Dart_CreateLoadingUnitCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_CreateLoadingUnitCallbackFunction>>;
typedef Dart_StreamingWriteCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> callback_data,
    ffi.Pointer<ffi.Uint8> buffer,
    ffi.IntPtr size);
typedef DartDart_StreamingWriteCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> callback_data,
    ffi.Pointer<ffi.Uint8> buffer,
    int size);
typedef Dart_StreamingWriteCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_StreamingWriteCallbackFunction>>;
typedef Dart_StreamingCloseCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> callback_data);
typedef DartDart_StreamingCloseCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> callback_data);
typedef Dart_StreamingCloseCallback
    = ffi.Pointer<ffi.NativeFunction<Dart_StreamingCloseCallbackFunction>>;
typedef Dart_DwarfStackTraceFootnoteCallbackFunction = ffi.Pointer<ffi.Char>
    Function(ffi.Pointer<ffi.Pointer<ffi.Void>> addresses, ffi.IntPtr count);
typedef DartDart_DwarfStackTraceFootnoteCallbackFunction = ffi.Pointer<ffi.Char>
    Function(ffi.Pointer<ffi.Pointer<ffi.Void>> addresses, int count);

/// Callback provided by the embedder that is used by the VM to
/// produce footnotes appended to DWARF stack traces.
///
/// Whenever VM formats a stack trace as a string it would call this callback
/// passing raw program counters for each frame in the stack trace.
///
/// Embedder can then return a string which if not-null will be appended to the
/// formatted stack trace.
///
/// Returned string is expected to be `malloc()` allocated. VM takes ownership
/// of the returned string and will `free()` it.
///
/// \param addresses raw program counter addresses for each frame
/// \param count number of elements in the addresses array
typedef Dart_DwarfStackTraceFootnoteCallback = ffi
    .Pointer<ffi.NativeFunction<Dart_DwarfStackTraceFootnoteCallbackFunction>>;
typedef nativeCallableTestCallbackTypeFunction = ffi.Void Function(
    ffi.Int x, ffi.Pointer<ffi.Int> ret);
typedef DartnativeCallableTestCallbackTypeFunction = void Function(
    int x, ffi.Pointer<ffi.Int> ret);
typedef nativeCallableTestCallbackType
    = ffi.Pointer<ffi.NativeFunction<nativeCallableTestCallbackTypeFunction>>;
typedef NativeHttpCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Char> resp);
typedef DartNativeHttpCallbackFunction = void Function(
    ffi.Pointer<ffi.Char> resp);
typedef NativeHttpCallback
    = ffi.Pointer<ffi.NativeFunction<NativeHttpCallbackFunction>>;

const int kNativeArgNumberPos = 0;

const int kNativeArgNumberSize = 8;

const int kNativeArgTypePos = 8;

const int kNativeArgTypeSize = 8;

const int kNativeArgNumberPos$1 = 0;

const int kNativeArgNumberSize$1 = 8;

const int kNativeArgTypePos$1 = 8;

const int kNativeArgTypeSize$1 = 8;

const int DART_FLAGS_CURRENT_VERSION = 13;

const int DART_INITIALIZE_PARAMS_CURRENT_VERSION = 9;

const int ILLEGAL_PORT = 0;

const String DART_KERNEL_ISOLATE_NAME = 'kernel-service';

const String DART_VM_SERVICE_ISOLATE_NAME = 'vm-service';

const String kSnapshotBuildIdCSymbol = '_kDartSnapshotBuildId';

const String kVmSnapshotDataCSymbol = '_kDartVmSnapshotData';

const String kVmSnapshotInstructionsCSymbol = '_kDartVmSnapshotInstructions';

const String kVmSnapshotBssCSymbol = '_kDartVmSnapshotBss';

const String kIsolateSnapshotDataCSymbol = '_kDartIsolateSnapshotData';

const String kIsolateSnapshotInstructionsCSymbol =
    '_kDartIsolateSnapshotInstructions';

const String kIsolateSnapshotBssCSymbol = '_kDartIsolateSnapshotBss';

const String kSnapshotBuildIdAsmSymbol = '_kDartSnapshotBuildId';

const String kVmSnapshotDataAsmSymbol = '_kDartVmSnapshotData';

const String kVmSnapshotInstructionsAsmSymbol = '_kDartVmSnapshotInstructions';

const String kVmSnapshotBssAsmSymbol = '_kDartVmSnapshotBss';

const String kIsolateSnapshotDataAsmSymbol = '_kDartIsolateSnapshotData';

const String kIsolateSnapshotInstructionsAsmSymbol =
    '_kDartIsolateSnapshotInstructions';

const String kIsolateSnapshotBssAsmSymbol = '_kDartIsolateSnapshotBss';
